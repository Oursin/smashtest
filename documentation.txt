What is SmashTEST?
    - Generates and executes functional, (?)(load, and security tests) from a test tree
        - Geared towards UI browser testing, but can be used for anything
        - NodeJS for now
    - Example
    - Easier to create tests as a tree, makes you think of all permutations on a single page or input.
        Represents how a tester comes up with test cases (tester thinks breadth-first, user thinks depth-first).

Setup
    - Installation
        - npm
        - Use even-numbered version of nodejs
        (?) - Install webdriverjs and/or selenium separately? See webdriverjs installation guide and try to install it as a dependency
        - https://github.com/SeleniumHQ/selenium/tree/master/javascript/node/selenium-webdriver
    - Installing SmashPANEL Lite too
        - What it does and why it's recommended

Example file
    - One big example file with each type of step, etc. and // comments explaining stuff

Steps
    - Textual steps, packaged steps, functions
    - Each "branch" is a separate test. We call tests "branches".
    - Indents
        - 4 spaces for indents (no tabs)
        - Like indented comments on a site like Reddit, where each chain of replies is a branch
    - Blank lines generally don't matter
        - Use them for stylistic organization and to group similar steps
        - Recommended to put a blank line above and below a step block, to make it easier to see.
        - You can also use blank lines to prevent a step block from forming, since step blocks require consecutive lines
    - Identifiers are symbols that can come before or after the step. Usually after is recommended, for consistency.
    - Generally stored in smashfiles (.smash), but can be any kind of text file

Running tests
    - Basic command line invocation
        - File glob passed in
            - All files are merged into one big one, and everything at the top level is accessible to everything in other files
            - If glob omitted, *.smash is default
        - Setting {vars} from command line
        - Branches are run in order of {frequency}, high to low, where no {frequency} is med
    - Command line options
        - --repl or -r
        - --maxInstances=5
            - 5 if omitted
        - --noDebug
        - --debug=[HASH] or -d
            - Only run that branch as debugged. Ignore $'s, ~'s, groups, and frequency
        - --noReport
        - --reportDomain=http://domain:port
            - This is where the apis will be exposed for reports to get live updates
            - Port indicates what port smashtest should run on
                - If omitted, an open port will be chosen, starting with port 9000
            - Domain indicates the domain of the machine you're running smashtest on
                - If omitted, localhost will be chosen
                - Choose a domain other than localhost for when you're running tests in CI and want people to hit the report externally
            - https currently doesn't work - if you use it it acts like http
        - --noReportServer
        - --screenshots=false (default is true)
        - --skipPassed or -s
            - Doesn't run branches that passed last time. Carries them and their state over into the new report.
                - Runs everything else (new branches/changed branches, branches that failed last time, branches that didn't run last time)
                - Doesn't run branches that have since been removed from the tree
                - Always runs the current hooks, not the hooks from the last run
            - For fixing problems in your tests that cause them to break, without having to rerun the whole entire suite again
            - Helpful for when you are typing out new tests (or updating existing ones) and only want to run whatever's new
            - Format
                - -s/-skipPassed=filename or "filename"
                    - filename of report that constitutes last run
                - -s/-skipPassed with no filename
                    - Uses latest report from <current dir>/reports that didn't have a ~ (~ reports have "debug" at the end of their filenames)
                    - If one isn't found, uses report.html in the current directory
        - --groups=value or "val1 val2 val3"
        - --group=value (you can do many of these - great for group names with spaces)
        - --minFrequency=med
            - med if omitted
        - --g:varname=value or "value" (global var)
        - --p:varname=value or "value" (persistent var)
        - --version/-v
        - --help/-?
    - Config file, config.json, in the same dir as you're running the command will set flags, but command-line flags will override
    - For CI, exits with exit code 1 if at least one branch failed, 0 otherwise. This only applies to non-REPL runs.

Reports
    - Where to find the report
        - report.html in directory where smashtest run
            - Live updates. Click a step/branch to pause live updates.
        - dates/
            - Snapshots, not live
            - _debug.html for debug runs
        - localhost:9000 (if 9000 isn't taken)
            - Live updates
            - Not recommended since this endpoint dies when smashtest ends. Use report.html instead (see console output for absolute path).
    - Pass/fail and expected/unexpected
        - Steps
            - A step passes is no errors are thrown inside of it
            - A step fails if an error is thrown inside of it
            - A step is marked expected if it passes, or unexpected if it fails
                - However, if the step has a # identifier, it will be marked expected if it fails, and unexpected if it passes
                - An error will show up in the report if a step is _unexpected_ (as opposed to passed or failed)
                - Give an example of using #: a step fails, you file a defect, put in # and comment with bug tracker number so the
                    test doesn't keep bothering you (it may be a low priority defect that isn't being fixed yet). Once it's fixed,
                    the step will unexpectedly pass (and the branch will fail), you will notice, close off the bug tracker defect, and
                    remove the # and comment.
        - Branches
            - A branch will pass if all steps are as expected
            - A branch will fail if one or more steps are unexpected
        - Error.continue
            - If the error obj thrown inside a step has error.continue set to true, the branch will continue executing, though it will still fail
                if there is one or more unexpected errors
            - If error.continue isn't set to true, and if the error was unexpected, the step will be marked as an unexpected fail, the branch will
                be failed immediately, and all other branches that go through that step will be automatically skipped (there's no point in repeating steps that are doomed to fail)
        - Timeouts are set by each step on a case-by-case basis
    - Reading stack traces in errors
        - Error of step = filename and line number in filename
        - Stack trace = at CodeBlock_for_[NAME OF CODE BLOCK FUNCTION] (eval at ...), <anonymous>:[LINE NUMBER]:[COL NUMBER])
            - [LINE NUMBER] is the line in the file containing [NAME OF CODE BLOCK FUNCTION]
        - Implement complex functions in their own js files to generate more traditional stack traces
    - Sample screenshot and summary
    - What's in a name?
        The only real way to name a test is to concatenate the steps together, as tests are detailed and many of them differ by
        just one step. When you name a test, you're really just providing a crude summary of one of the steps towards the end.
        Really, naming is useless and only slows you down.

Step blocks
    - Vertical list of 2 or more steps, no blank lines in between
    - Must end in an empty line if it has children
    - Show examples
    - Each line of a step block will connect with every child step to the step block, in a separate branch. It's kind of like a for loop.
        - Give an example
    - .. at the top of a step block means sequential execution. Kind of like if we indented every step into a tree.
        - .. must be at the same indentation as vertical list
        - Function in the list with multiple branches will cause the list to branch (give example - like the one in the Hooks section below)
    - Code block ok but only if it's last member
        - Example: Debug pattern
            Step to debug

                becomes

            ..
            Step to debug
            Debug {
                console.log("something")
            }

Textual steps (-)
    - -, -M, or -T

Step reference
    - From built-in packages
    - Browsers, Webdriver steps, Verify, Assertions, Wait, etc.

Code reference
    - JS functions available as part of built-in packages
    - execInBrowser()
    - Timeout code

ElementFinders
    - [OPTIONAL(1st/2nd/3rd/etc.)   MANDATORY('TEXT' AND/OR VAR-NAME)   OPTIONAL(next to 'TEXT')]
    - Examples
        - [ 'Login' box ]
        - [ 'Login' ]
            - Any element that's an a, button, input, textarea, etc.  or is clickable/has a click handler and contains text 'Login' (see SmashPANEL implementation)
        - [ 'Login' box next to 'foo' ]
        - [ box next to 'foo' ]
        - [ box ] (although you could use {box} too)
        - [ 4th 'Login' box ]
        - [ 4th 'Login' next to 'foo' ]
    - Explain the basics of the find algorithm
    - May contain vars
        - [ {{N}}th 'some {text}' next to '{{something}}' ]
            Note: "th" can be applied to any number

Functions
    - Calling
        - Examples of calls (include {vars}, {{vars}}, 'strings', "strings", [strings], and vars inside of strings)
        - Vars and strings designate parameter inputs in a function call
        - Function {{var}} here OR Function "6" here OR Function ['element' finder] here maps to * Function {{other var}} here
            - All function inputs are either {vars}, {{vars}}, 'strings', "strings", or [strings]
            - {{vars}} in a function declaration must all be {{local}}, not {global}
        - Finds closest matching function declaration in the tree (always looking top to bottom among siblings), otherwise looks to packaged functions
            - Function declaration that ends in * matches any function call that starts with that declaration (extra text at end is ok)
        - When a *function ends in multiple leaves, those are separate branches for the indented line below function call
            - Show example
    - Declaring
        - Examples of declarations
            - * Public function declaration
            - ** Private function declaration
            - *** Hook declaration
        - {{local vars}} designate parameters in a function declaration
        - Finding declaration
            - First look to siblings, then to siblings of parent, etc.
            - Match custom functions first, then primitive packaged functions
            - Don't forget about functions declared within function F. A call to F makes the functions accessible to its children
                - Functions and {vars} declared inside a function are accessible to children of the caller step
    - Functions are case insensitive, leading and trailing whitespace is ignored, and whitespace in the middle is always treated as a single space
    - When * F has a call to F inside it, that call will find the closest * F, but not the parent * F.
        - Prevents infinite loops and allows a specific function to call a more generic one
        - For example, declare a * Navigate to intercept Navigate children, do something like logging or security checks, then
            call Navigate to pass control to the generic * Navigate
            * Navigate to {{url}}
                Security checks
                    Navigate to {{url}} // call to the generic one
    - Examples (maybe distribute these among the sections above)
        - Using functions to encapsulate common steps
        - Using functions to enumerate branches (like a step block but with multiple levels, or the whole {x}=F thing)
        - Using functions to organize testing (have a high-level tree that describes your app, where each leaf is a function call to a function with multiple branches, where all the testing for that specific component occurs)
        - Use this function in a test, and it will automatically split into two branches, each of which tests a different way to get to the same place
            * Select beans and rice
                Variant 1 - ..
                    Click Beans
                    Click Rice

                Variant 2 - ..
                    Click Rice
                    Click Beans

                (Also useful for "Get to page X", where you can either click a link or enter a url)
                (Also useful for "Select option X", and doing it via keyboard and mouse, or a combination of both -
                    great for accessibility testing)
        - On Page X pattern, with verifications and setting global vars to selectors in a .. step block
        - Setting context pattern, e.g., Open browser X will establish Click, etc. as browser-oriented functions. But a future call
            to something like Open phone (whose function declaration has its own declarations for Click, etc.) sets the "context" to the phone,
            sending further child steps to the phone's functions
        - Inheritance pattern
            * On special cart page
                On cart page
                    Validate special cart stuff // this has to come last

                    * Clear cart // function that overrides a generic cart function
                        Specific stuff
                            Clear cart // call to that generic cart function

            * On cart page
                * Clear cart
                    Generic stuff

            On special cart page
                Clear cart // specific stuff, then generic stuff
    - Pitfalls
        - Since strings and vars designate inputs, always use \', \", \[, \] when using those actual characters inside a step's text or in a string, to prevent a parameter from forming

Variables
    - Types of vars
        - {var} is global
            - Exists for the life of the branch
            - Steps below where {var} is declared will have access to {var}, which includes inside function calls
            - If {var} is declared inside a function, it will be accessible in the caller after the function call step
            - Accessible within Every Branch/Step hooks, for hooks that apply to branches where the var was declared
        - {{var}} is local (internal to the function)
            - Goes out of scope at the end of the function and is not accessible within function calls inside the function declaration
            - A local var is accessible inside the code block of a non-function-call step ( Text {code block} )
        - Persistent vars also exist, but are only accessible in code blocks. They persist from branch to branch, for the lifetime of the whole run.
            You shouldn't normally have to use these in your day-to-day testing. Only for advanced, internal stuff.
    - Where to use them (they are replaced with their value)
        - Function call
            F {var1} {{var2}}
        - String literal
            'string literal {var1}', "string literal {{var2}}", or [string literal {var3}]
    - Setting vars
        - {var} = 'String' (or "String" or [String])
            - To clone a var, use {var}='{var2}'
            - {var1}='str1', {var2}='str2', etc.
                - When setting multiple vars in a single line, use commas to separate them. Strings only. No functions.
            - Right now, only ' and " can be escaped with a backslash inside a string literal
                - To set a string to something more complex, use
                    {var} = Func {
                        return "\n\t";
                    }
        - {var} = Function with a code block
            - Code Function returns a string (actually any kind of js value will work)
            - Could be {var} = Text { code block that returns something }
        - {var} = Function with branches
            - Each line must be {x}='value' (or "value" or [value])
                - No children
            - Separate branches will be created, each setting {var} to each 'value' encountered to the right of {x}
            - You can name {x} whatever you want, but the convention is {x}
    - Lookahead
        - {vars} that will be defined later in the branch
        - Allows you to refactor common steps higher up into the tree. Provide an example with different {usernames}.
        - You cannot set a lookahead {var} = Function, where the Function returns async
        - You cannot set a lookahead var inside a function's code block (via var=something or g()/l()). Must be {var}='value'.
    - Variables are case insensitive, leading and trailing whitespace is ignored, and whitespace in the middle is always treated as a single space
        - Case sensitive as js vars and in persistent/global/local though (use the case that was used when declared - though leading and trailing whitespace is ignored too)
    - Pitfalls
        - Cannot have a \ in the name of a variable

Comments
    - // only, stuff before it is a legit step
    - If whole line starts with //, it's ignored as if it weren't there
        - For example
            A
            // B
            C
                is still a step block, with members A and C

    - Use -T to "comment out" everything under a step (see To-Do identifier section)

Code blocks
    - Types
        - * Function {code}
        - Textual step {code} or Textual step - {code}
    - Code blocks end on a line that starts with '}' and is the exact number of indents as the step that started the code block
    - +, .., etc. characters applied come after the step text and before the {
    - Only lines after the { line and before the } count as part of the code block
    - Variables
        - Get
            - {{var1}} is var1 or l("var1") or getLocal("var1")
            - {var2} is var2 or g("var2") or getGlobal("var2")
            - persistent vars persist from branch to branch, for the life of the whole test run and are only accessible via p("var3") or getPersistent("var3")
            - More on js vars
                - When persistent, global, and local vars share the same name, the js var will be set according to this precedence: local, global, persistent
                - Vars whose names have anything but [A-Za-z0-9\-\_\.] won't be converted to js vars
                - Vars whose names are a reserved js keyword won't be converted to js vars
        - Set
            - {{var1}} is l("var1", "value") or setLocal("var1", "value") (NOTE: you can't set var1=value as this will not persist past the end of the code block)
            - {var2} is g("var2", "value") or setGlobal("var2", "value")
            - persistent vars: p("var3", "value") or setPersistent("var3", "value")
    - JS functions and variables available
        - l(), g(), p()
        - getLocal(), getGlobal(), getPersistent()
        - setLocal(), setGlobal(), setPersistent()
        - getStepText() - great for when matching first part only
        - log(string)
        - i(packageName, varName) - sets persistent var varName and returns the object (if varName omitted, generates it by camel casing packageName, e.g., one-two-three --> oneTwoThree)
            - Usage: let chai = i('chai');
        - runInstance object (quick summary)
            - runInstance.currStep
            - runInstance.currBranch
            - runInstance.tree
        - runInstance.runner Object (quick summary)
        - throw new Error("error msg")
    - JS file pattern
        - Discuss putting complex code into its own js file, and doing this in a code block: {
            let yf = i('./yourfile.js', 'yf');
            yf.something();
        }
            - Helps a lot with stack traces. Code blocks are recommended for short snippets of code, 1-5 lines long.
    - Pitfalls
        - Don't use a var in a js code block that's set in a later step. That trick only works for {vars} that are used and set outside of code blocks.
        - Don't set a variable by using varname= when you want that value to persist beyond the end of the code block. Use setter functions (i.e., l(), g(), p()) instead.

Sequential execution (..)
    - .. at the end of a step
        - .. means execute branches at and below me depth-first sequentially
            - The steps at and below a .. are expanded normally, then executed sequentially
            - ..'es have the effect of flattening themselves and their children into one long list of sequentially indented steps
        - Give examples

            Something - ..
                One -
                    Two -
                    Three -
                Four -
                    Five -

                is

                1) Something
                2) One
                 etc.

            Test the editbox without navigating off the page ..

                Enter bad value 1
                Enter bad value 2
                Enter bad value 3

                    Verify error

        - a .. inside a *Function declaration does not expand beyond the bounds of that *Function declaration
        - If a function call is at or below the .. line, and it has multiple branches inside, the multiple branches will
            be combined sequentially.
            - Give an example

                Test the editbox without navigating off the page ..
                    Enter bad values
                        Verify error

                    * Enter bad values
                        Enter bad value 1
                        Enter bad value 2
                        Enter bad value 3

    - .. above a step block
        - Acts differently from the .. that comes at the end of a line
        - Only applies to the step block, not to the step block's children
        - If step block contains a function with multiple branches, the multiple branches won't be combined sequentially as with the
            .. at the end of a step. Rather, multiple branches will be generated.
            - Give an example
                ..
                Add item to cart
                Go to cart page
                Verify something on cart

                * Go to cart page  // Two different ways of getting to the cart
                    Navigate to '/cart'

                    Click {cart button in header}

    - Show more examples from bottom of test_language_sample.txt

No parallel execution (+)
    - No two child branches may execute simultaneously

Expected failure (#)
    - #
    - Recommended to put a comment after the #, linking to a bug tracker ticket, etc.

To-Do (-T)
    - Marks this step and those under it as todo
    - Treated as a textual step
    - Only one branch going through this step will be run, the rest will be skipped as repeats

Manual tests (-M)
    - Marks this step and those under it as manual
    - Treated as textual step, but you can ask to generate manual checklist from command line
    - Only one branch going through this step will be run, the rest will be skipped as repeats

Only ($)
    - $ = Only run branches under this step, but no debugging.
        - Show example. Comes at the beginning or end of the step, including before a function declaration's *.
            - Beginning is recommended, so you can easily see which lines are $'ed
        - Multiple $'s with the same parent (on the same indent level) only run branches that fall under one of these branches (OR)
        - You can put $'s at different levels to isolate a branch or branches
        - Give more examples

Debug (~)
    - Debug identifier (~)
        - Show example. Comes before or after a step, including before a function declaration's *.
        - Before means pause right before this step executes, after means pause right after
    - Isolates a single branch and pauses right before the step marked ~ and opens up the REPL
    - Pauses right after a step if it fails (or unexpectedly passes)
    - Use multiple $'s and ~'s to isolate a single branch to debug (or you can use multiple ~'s)

REPL
    - What REPL does, show screenshot and a one sentence description
    - Starting REPL
        - -repl
            - No filenames - kicks off blank browser and REPL
            - Filenames - it will load the first branch but open up repl before first step begins
        - ~ in test file
    - REPL commands
        - Enter key, s, p, r, x
        - Enter a step to run it
            - One line only
            - Multiple lines only if step has a code block
                - End the code block by entering a }
            - No function declarations
        - Ctrl + C to exit
        - Other options
            .break    Sometimes you get stuck, this gets you out
            .clear    Break, and also clear the local context
            .editor   Enter editor mode
            .exit     Exit the repl
            .help     Print this help message
            .load     Load JS from a file into the REPL session
            .save     Save all evaluated commands in this REPL session to a file

Selective test running
    - Only identifier ($)
    - Groups
        - Choosing which groups to run from variable, or from command line
        - When multiple group vars are set in a branch, the branch belongs to all groups
    - Frequency
        - Choosing which frequencies to run from {frequency}='high/med/low', or from command line
            - You can choose to run tests from a frequency, and above
            - Recommendations = high = most important tests (BVT), med = normal tests, low = all long-term tests (e.g., security tests)
        - The value of {frequency} at the leaf is what controls the frequency of that branch
        - Branches are also run in order of frequency, from high to low, where no frequency is med
        - Recommended to sort the children of a step by their frequency
    - When noDebug command line flag is set, a ~ or $ anywhere in your tree will cause an error
        - Great for making sure you're not debug prior to committing test files to CI

Testing APIs
    - Tutorials on how to test APIs (using existing npm libraries in code blocks)
        - fetch + chai subsets?
            - https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch
            - swapi.co for sample data

Stubbing out APIs
    - Examples
        - Use packaged sinon-injecting js function
        - Stubs out XHR
            - https://sinonjs.org/releases/latest/fake-xhr-and-server/
            - Give examples of a few GET/POST routes and their responses
        - Restores original XHR once test is over

CI/CD Integration
    - Exit codes 0 and 1
    - -reportDomain

Hooks (***)
    - Piece of code that runs at certain points. Not for testing. For internal stuff, like reporting, requires,
        js function declarations, screenshotting, logging, etc.
    - *** Before Every Branch
        - runs before every branch that goes through this function declaration's parent
    - *** After Every Branch
        - runs after every leaf under this function declaration's parent
    - *** Before Every Step
    - *** After Every Step
        - Examples
            - Taking a screenshot
    - *** Before Everything
        - before any branches begin, execute this
        - only valid at 0 indents
        - applies to all branches from all files you put in your glob
        - Examples
            - setInterval() that runs in the background and checks for a popup, then closes it
            - require() in a library (figure out how to do this)
    - *** After Everything
        - after all branches end, execute this
        - only valid at 0 indents
        - applies to all branches from all files you put in your glob
        - When smashtest app is being closed via Ctrl + C, After Everything code blocks will be exected synchronously, as there
            is not enough time before the process exists. If you have async code, check the isSync js variable beforehand to see if
            the code block is being executed sync.
    - Code blocks only. They cannot have children.
    - You're not allowed to have any identifiers (~, $, .., -T, etc.) on them
    - Hooks won't have a pass/fail state. If a hook fails, the step/branch it corresponds to will take the error.
    - Setting runInstance.currStep.htmlReport (for right pane)
    - These are recommended for internal framework stuff, like reporting (so you can run this code whether or not the step failed)
        - Setup/teardown too, though that should really be part of the test itself
            i.e.,
            My Test -
                ..
                Setup (teardown should really be here, so each test has a clean slate)
                Steps
                Teardown

            * Setup
                A (includes the same login as teardown, to clear out old state)

            * Steps
                B
                    C
                D

            * Teardown
                E

Packages
    - Just create a file with a *** Before Everything that injects what it needs. Then just distribute this file and have users
        put it into packages/
    - Give some examples
        - Show injection being made into Runner.persistent.packageName
