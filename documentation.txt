What is SmashGEN?
    - Generates and executes functional, (?)(load, and security tests) from a test tree
        - Geared towards UI browser testing, but can be used for anything
        - NodeJS for now
    - Example
    - Easier to create tests as a tree, makes you think of all permutations on a single page or input.
        Represents how a tester comes up with test cases (tester thinks breadth-first, user thinks depth-first).

Setup
    - Installation
        - npm
        - Use even-numbered version of nodejs
        (?) - Install webdriverjs and/or selenium separately? See webdriverjs installation guide and try to install it as a dependency
    - Installing SmashPANEL Lite too
        - What it does and why it's recommended

Steps
    - Textual steps, built-in steps, functions
    - Each "branch" is a separate test. We call tests "branches".
    - Indents
        - 4 spaces for indents (no tabs)
        - Like indented comments on a site like Reddit, where each chain of replies is a branch
    - Blank lines generally don't matter
        - Use them for stylistic organization and to group similar steps
        - Recommended to put a blank line above and below a step block, to make it easier to see.
        - You can also use blank lines to prevent a step block from forming, since step blocks require consecutive lines

Running tests
    - Branches run breadth-first
    - Basic command line invocation
        - File glob passed in
        - Setting {vars} from command line

Configuration
    - Timeouts
    - Max browser instances

Output
    - Console
    - Report
        - Test failures

Step reference
    - Browsers, Webdriver steps, Verify, Assertions, Wait, etc.
    - Mocking APIs (it has its own section too)
    - Execute in browser {}

Step blocks
    - Vertical list of 2 or more steps, no blank lines in between
    - Show examples
    - Each line of a step block will connect with every child step to the step block. It's kind of like a for loop.
    - .. at the top of a step block means sequential execution. Kind of like if we indented every step into a tree.
        - .. must be at the same indentation as vertical list

Textual steps (-)

ElementFinders
    - [OPTIONAL(1st/2nd/3rd/etc.)   MANDATORY('TEXT' AND/OR VAR-NAME)   OPTIONAL(next to 'TEXT')]
    - Examples
        - [ 'Login' box ]
        - [ 'Login' ]
            - Any element that's an a, button, input, textarea, etc.  or is clickable/has a click handler and contains text 'Login' (see SmashPANEL implementation)
        - [ 'Login' box next to 'meow' ]
        - [ box next to 'meow' ]
        - [ 4th 'Login' box ]
        - [ 4th 'Login' next to 'meow' ]
    - Explain the basics of the find algorithm

Functions
    - Calling
        - Examples of calls (include vars, strings, vars within strings, and elementFinders)
        - Function {var} here OR Function "6" here OR Function ['element' finder] here maps to * Function {{other var}} here
            - All function inputs are either {vars}, "strings", or [ElementFinders]
        - Finds closest matching function declaration in the tree, otherwise looks to built-in functions
        - When a *function ends in multiple leaves, those are separate branches for the indented line below function call
    - Declaring
        - Examples of declarations
        - Finding declaration
            - First look to siblings, then to siblings of parent, etc.
            - Match custom functions first, then primitive built-in functions
            - Don't forget about functions declared within function F. A call to F makes the functions accessible to its children
    - Pitfalls
        - Functions must match case (if they don't it's a compile error), but may include varying whitespace

Variables
    - Types of vars
        - {var} is global (steps below the function call will have access to {var})
        - {{var}} is internal to the function (it goes out of scope at the end of the function)
    - Setting vars
        - {var} = 'String' (or "String")
        - {var} = Function with a code block
            - Code Function returns a string (actually any kind of js value will work)
            - Could be {var} = Text { code block that returns something }
        - {var} = Function with branches
            - Function is a list of textual steps that will be turned into strings
            - Line is turned into a code block, where {var} = each string
    - In a line that's {var1}=Step1, {var2}=Step2, do not accept Functions* in Step1/2/etc.
        - (In other words, if there are multiple vars being set, each Step must be a string literal)
    - Using {vars} that will be defined later in the branch
        - Allows you to refactor common steps higher up into the tree. Provide an example with different {usernames}.
    - Pitfalls
        - Cannot have a \ in the name of a variable
        - Whitespace in front of and behind a variable name doesn't count

Comments

Code blocks
    - Types
        - * Function {code}
        - Textual step {code} // - is optional
        - Execute in browser {code}
    - Code blocks end on a line that starts with '}' and is the exact number of indents as the step that started the code block
    - +, .., etc. characters applied come after the step text and before the {
    - Only lines after the { line and before the } count as part of the code block
    - Vars accessible in code as global.name (or global["var name"]) or local.name (or local["var name"])
        - Vars that persist from branch to branch are stored in persistant

To-Do (-T)
    - Marks this branch and those under it as todo

Debug and REPL (~)
    - ~ (debug identifier)
    - ~~ (step-by-step debug identifier)
    - Using REPL
    - Kicking off blank browser and REPL just from the command line

No parallel execution (+)
    - No two child branches may execute simultaneously

Sequential execution (..)
    - .. means execute branches below me depth-first sequentially, but never repeat the execution of a parent step (including me)
        more than once.  ..'es have the effect of flattening themselves and their children into one long list of sequentially
        indented steps, a .. does not expand beyond the bounds of a *Function
    - .. above a step block

Expected failure (#)
    - #
    - Recommended to put a comment after the #, linking to a bug tracker ticket, etc.

Must Test
    - Must Test X
    - Subtree = Is every branch in X represented below me? (me = full tree, including function expansions, not including other Must Test statements)
    - Must Test {var} = List
        - Makes sure every {var} = list member is included in the subtree
        - List format has to be (where the var names can be anything, not just {x})
            List
                {x}='str1'
                {x}='str2'

Hook steps
    - * After every branch
        - {branchSuccessful} = true if passed, false if failed
        - {error} = the Error object, if failed
        - attached to the end of every leaf under this function declaration's parent
    - * Before everything
        - before any tests begin, execute this
        - only valid at 0 indents
    - * After everything
        - after all tests end, execute this
        - only valid at 0 indents

Mocking APIs

Only ($)
    - $ = Only run branches under this step, but no debugging.
        - Multiple $'s that intersect only run tests that fall under both (AND)
        - Multiple $'s that do not intersect run tests that fall under either (OR)

Selective test running
    - Only identifier ($)
    - Groups
        - Choosing which groups to run from variable, or from command line
    - Frequency
        - Choosing which frequencies to run from variable, or from command line
        - Overrides breadth-first algo when choosing which branch to run next

Run tests that failed last time

Manual tests (-M)
    - Marks this branch and those under it as manual
    - Treated as textual step, but you can ask to generate manual checklist from command line
