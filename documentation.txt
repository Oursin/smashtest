What is SmashGEN?
    - Generates and executes functional, (?)(load, and security tests) from a test tree
        - Geared towards UI browser testing, but can be used for anything
        - NodeJS for now
    - Example
    - Easier to create tests as a tree, makes you think of all permutations on a single page or input.
        Represents how a tester comes up with test cases (tester thinks breadth-first, user thinks depth-first).

Setup
    - Installation
        - npm
        - Use even-numbered version of nodejs
        (?) - Install webdriverio or selenium separately? See webdriverio installation guide and try to install it as a dependency
    - Installing SmashPANEL Lite too
        - What it does and why it's recommended

Steps
    - Textual steps, built-in steps, functions
    - Indents
        - 4 spaces for indents (no tabs)
        - Like indented comments on a site like Reddit, where each chain of replies is a branch
    - Blank lines generally don't matter, except to denote step blocks. Use them for stylistic organization.
        - Blank lines are like a “big parenthesis” around multiple steps

Running tests
    - Branches generated breath first
    - Basic command line invocation
        - File glob passed in
        - Setting {vars} from command line
    - js is generated, passed to webdriverio

Configuration
    - Timeouts
    - Max browser instances

Output
    - Console
    - Report
        - Test failures

Step reference
    - Browsers, Webdriver steps, Verify, Assertions, Wait, etc.
    - Mocking APIs (it has its own section too)
    - Execute in browser {}

Step blocks
    - What consititutes a step block
        - Start with either the start of file, blank line, or ..
        - End with either blank line or end of file
        - Only a vertical list with no children, no blank lines
    - Each line of a step block will connect with every child step to the step block. It's kind of like a for loop.
    - .. at the top of a step block means sequential execution. Kind of like if we indented every step into a tree.

Textual steps (-)

ElementFinders

Functions (*)
    - Calling
        - Examples of calls (include vars, strings, vars within strings, and elementFinders)
        - Function {var} here * or Function "6" here maps to * Function {other var} here
            - All function inputs are either {vars} or "strings"
    - Declaring
        - Examples of declarations
        - When a *function ends in multiple leaves, those are separate branches for the indented line below function*
        - Finding declaration
            - First look to siblings, then to siblings of parent, etc.
            - Match custom functions first, then primitive built-in functions
            - Don't forget about functions declared within function F. A call to F makes the functions accessible to its children.
    - Pitfalls
        - A declared but uncalled function causes a warning

Variables
    - Types of vars
        - {var} is global
        - {{var}} is internal to the function
    - Setting vars
        - {var} = 'String' (or "String")
        - {var} = Code Function
            - Code Function returns a string
        - {var} = Function
            - Function is a list of textual steps that will be turned into strings
            - Line is turned into a code block, where {var} = each string
    - In a line that's {var1}=Step1, {var2}=Step2, do not accept Functions* in Step1/2/etc.
        - (In other words, if there are multiple vars being set, each Step must be a string literal)
    - Using {vars} that will be defined later in the branch
        - Allows you to refactor common steps higher up into the tree. Provide an example with different {usernames}.
    - Pitfalls
        - Cannot have a \ in the name of a variable

Comments

Code blocks
    - Types
        - * Function {code}
        - Textual step {code}
        - Execute in browser {js code}
    - Code blocks end on a line that starts with '}' and is the exact number of indents as the step that started the code block
    - +, .., etc. characters applied come after the step text and before the {
    - Vars accessible in code as vars["var name"] or localvars["var name"]

To-Do (-T)
    - Marks this branch and those under it as todo

Debug and REPL (~)
    - ~ (debug identifier)
    - ~~ (step-by-step debug identifier)
    - Using REPL
    - Kicking off blank browser and REPL just from the command line

No parallel execution (+)
    - No two child branches may execute simultaneously

Sequential execution (..)
    - executes branches below depth-first sequentially
    - .. above a step block

Expected failure (#)
    - #
    - Recommended to put a comment after the #, linking to a bug tracker ticket, etc.

Must Test
    - Must Test X
    - Subtree = Is every branch in X represented below me? (me = full tree, including function expansions, not including other Must Test statements)
    - Must Test {var} = List
        - Makes sure every {var} = list member is included in the subtree

Hook steps
    - * Before all branches
        - mark this step's siblings - before any branches going through them are executed, execute this
    - * After all branches
    - * Before every branch
        - mark this step's siblings - any branches going through these are where this step is called before
        - Show an example of doing a require() here, then accessing a js var in subsequent code functions
    - * After every branch
    - * Before every step
    - * After every step
    - * After failed step
        - mark this step's siblings - any branches going through - if a step fails, execute this right after
    - * After successful step

Mocking APIs

Selective test running
    - Groups
        - Choosing which groups to run from variable, or from command line
    - Frequency
        - Choosing which frequencies to run from variable, or from command line

Run tests that failed last time

Manual tests (-M)
    - Marks this branch and those under it as manual
    - Treated as textual step, but you can ask to generate manual checklist from command line
