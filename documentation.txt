What is SmashTEST?
    - Generates and executes functional, (?)(load, and security tests) from a test tree
        - Geared towards UI browser testing, but can be used for anything
        - NodeJS for now
    - Example
    - Easier to create tests as a tree, makes you think of all permutations on a single page or input.
        Represents how a tester comes up with test cases (tester thinks breadth-first, user thinks depth-first).

Setup
    - Installation
        - npm
        - Use even-numbered version of nodejs
        (?) - Install webdriverjs and/or selenium separately? See webdriverjs installation guide and try to install it as a dependency
    - Installing SmashPANEL Lite too
        - What it does and why it's recommended

Steps
    - Textual steps, built-in steps, functions
    - Each "branch" is a separate test. We call tests "branches".
    - Indents
        - 4 spaces for indents (no tabs)
        - Like indented comments on a site like Reddit, where each chain of replies is a branch
    - Blank lines generally don't matter
        - Use them for stylistic organization and to group similar steps
        - Recommended to put a blank line above and below a step block, to make it easier to see.
        - You can also use blank lines to prevent a step block from forming, since step blocks require consecutive lines
    - Pitfalls
        - Always use \' or \" when the same line has 'strings' or "strings".
            - ' and \', and " and \" will match each other, but you should use \' and \" to prevent a string literal from forming in a function call

Running tests
    - Basic command line invocation
        - File glob passed in
            - All files are merged into one big one, and everything at the top level is accessible to everything in other files
        - Setting {vars} from command line

Configuration
    - Timeouts
    - Max browser instances

Output
    - Console
    - Report
        - Test failures

Step reference
    - Browsers, Webdriver steps, Verify, Assertions, Wait, etc.
    - Mocking APIs (it has its own section too)
    - Execute in browser {}

Step blocks
    - Vertical list of 2 or more steps, no blank lines in between
    - Must end in an empty line if it has children
    - Show examples
    - Each line of a step block will connect with every child step to the step block, in a separate branch. It's kind of like a for loop.
        - Give an example
    - .. at the top of a step block means sequential execution. Kind of like if we indented every step into a tree.
        - .. must be at the same indentation as vertical list

Textual steps (-)

ElementFinders
    - [OPTIONAL(1st/2nd/3rd/etc.)   MANDATORY('TEXT' AND/OR VAR-NAME)   OPTIONAL(next to 'TEXT')]
    - Examples
        - [ 'Login' box ]
        - [ 'Login' ]
            - Any element that's an a, button, input, textarea, etc.  or is clickable/has a click handler and contains text 'Login' (see SmashPANEL implementation)
        - [ 'Login' box next to 'meow' ]
        - [ box next to 'meow' ]
        - [ box ] (although you could use {box} too)
        - [ 4th 'Login' box ]
        - [ 4th 'Login' next to 'meow' ]
    - Explain the basics of the find algorithm

Functions
    - Calling
        - Examples of calls (include vars, strings, vars within strings, and elementFinders)
        - Function {var} here OR Function "6" here OR Function ['element' finder] here maps to * Function {{other var}} here
            - All function inputs are either {vars}, "strings", or [ElementFinders]
        - Finds closest matching function declaration in the tree, otherwise looks to built-in functions
        - When a *function ends in multiple leaves, those are separate branches for the indented line below function call
            - Show example
    - Declaring
        - Examples of declarations
        - Finding declaration
            - First look to siblings, then to siblings of parent, etc.
            - Match custom functions first, then primitive built-in functions
            - Don't forget about functions declared within function F. A call to F makes the functions accessible to its children
    - Examples
        - Using functions to encapsulate common steps
        - Using functions to enumerate branches (like a step block but with multiple levels, or the whole {x}=F thing)
        - Using functions to organize testing (have a high-level tree that describes your app, where each leaf is a function call to a function with multiple branches, where all the testing for that specific component occurs)
    - Pitfalls
        - Functions must match case (if they don't it's a compile error), but may include varying whitespace

Variables
    - Types of vars
        - {var} is global (steps below the function call will have access to {var})
        - {{var}} is internal to the function (it goes out of scope at the end of the function)
    - Setting vars
        - {var} = 'String' (or "String")
        - {var} = Function with a code block
            - Code Function returns a string (actually any kind of js value will work)
            - Could be {var} = Text { code block that returns something }
        - {var} = Function with branches
            - Each line must be {x}='value'
                - No children
            - Separate branches will be created, each setting {var} to each 'value' encountered to the right of {x}
            - You can name {x} whatever you want, but the convention is {x}
    - In a line that's {var1}=Step1, {var2}=Step2, do not accept Functions* in Step1/2/etc.
        - (In other words, if there are multiple vars being set, each Step must be a string literal)
    - Using {vars} that will be defined later in the branch
        - Allows you to refactor common steps higher up into the tree. Provide an example with different {usernames}.
    - Pitfalls
        - Cannot have a \ in the name of a variable
        - Whitespace in front of and behind a variable name doesn't count

Comments

Code blocks
    - Types
        - * Function {code}
        - Textual step {code} // - is optional
        - Execute in browser {code}
    - Code blocks end on a line that starts with '}' and is the exact number of indents as the step that started the code block
    - +, .., etc. characters applied come after the step text and before the {
    - Only lines after the { line and before the } count as part of the code block
    - Vars accessible in code as global.name (or global["var name"]) or local.name (or local["var name"])
        - Vars that persist from branch to branch are stored in persistant

To-Do (-T)
    - Marks this branch and those under it as todo

Debug and REPL (~)
    - ~ (debug identifier)
    - ~~ (step-by-step debug identifier)
    - Using REPL
    - Kicking off blank browser and REPL just from the command line

No parallel execution (+)
    - No two child branches may execute simultaneously

Sequential execution (..)
    - .. means execute branches at and below me depth-first sequentially, but never repeat the execution of a parent step (including me)
        more than once
            - ..'es have the effect of flattening themselves and their children into one long list of sequentially indented steps
            - a .. inside a *Function declaration does not expand beyond the bounds of that *Function declaration
            - If a function call is at or below the .. line, and it has multiple branches inside, it will be executed as such:
                - All in one branch: 1st branch from top to bottom, flattened steps under function call, 2nd branch from top to bottom, flattened steps under function call, etc.
                - Give an example
    - .. above a step block
        - Only applies to the step block, not to the step block's children
        - Same rules if one of the steps in the step block is a function with multiple branches
    - Show examples from bottom of test_language_sample.txt

Expected failure (#)
    - #
    - Recommended to put a comment after the #, linking to a bug tracker ticket, etc.

Hook steps
    - * After Every Branch
        - {branchSuccessful} = true if passed, false if failed
        - {error} = the Error object, if failed
        - attached to the end of every leaf under this function declaration's parent
    - * Before Everything
        - before any branches begin, execute this
        - only valid at 0 indents
        - applies to all branches from all files you put in your glob
    - * After Everything
        - after all branches end, execute this
        - only valid at 0 indents
        - applies to all branches from all files you put in your glob

Mocking APIs

Only ($)
    - $ = Only run branches under this step, but no debugging.
        - Multiple $'s that intersect only run tests that fall under both (AND)
        - Multiple $'s that do not intersect run tests that fall under either (OR)

Selective test running
    - Only identifier ($)
    - Groups
        - Choosing which groups to run from variable, or from command line
    - Frequency
        - Choosing which frequencies to run from variable, or from command line

Run tests that failed last time

Manual tests (-M)
    - Marks this branch and those under it as manual
    - Treated as textual step, but you can ask to generate manual checklist from command line
