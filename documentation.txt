What is SmashTEST?
    - Generates and executes functional, (?)(load, and security tests) from a test tree
        - Geared towards UI browser testing, but can be used for anything
        - NodeJS for now
    - Example
    - Easier to create tests as a tree, makes you think of all permutations on a single page or input.
        Represents how a tester comes up with test cases (tester thinks breadth-first, user thinks depth-first).

Setup
    - Installation
        - npm
        - Use even-numbered version of nodejs
        (?) - Install webdriverjs and/or selenium separately? See webdriverjs installation guide and try to install it as a dependency
    - Installing SmashPANEL Lite too
        - What it does and why it's recommended

Steps
    - Textual steps, packaged steps, functions
    - Each "branch" is a separate test. We call tests "branches".
    - Indents
        - 4 spaces for indents (no tabs)
        - Like indented comments on a site like Reddit, where each chain of replies is a branch
    - Blank lines generally don't matter
        - Use them for stylistic organization and to group similar steps
        - Recommended to put a blank line above and below a step block, to make it easier to see.
        - You can also use blank lines to prevent a step block from forming, since step blocks require consecutive lines

Running tests
    - Basic command line invocation
        - File glob passed in
            - All files are merged into one big one, and everything at the top level is accessible to everything in other files
            - js files matched by glob are ignored
        - Setting {vars} from command line
        - Branches are run in order of {frequency}, high to low, where no {frequency} is med
    - Command line options
        - -repl
        - -maxInstances=5
            - 5 if omitted
        - -noDebug
        - -noReport
        - -rerunNotPassed or -r
            - -rerunNotPassed=filename or "filename"
                - filename of report that constitutes last run
            - -rerunNotPassed with no filename
                - Uses latest report from <current dir>/reports that didn't have a ~ (~ reports have "debug" at the end of their filenames)
                - If one isn't found, uses report.html in the current directory
        - -groups=value or "val1 val2 val3"
        - -minFrequency=med
            - med if omitted
        - -g:varname=value or "value" (global var)
            - g:screenshotOnFail=true
        - -p:varname=value or "value" (persistent var)

Only run what didn't pass last time
    - -rerunNotPassed
    - Doesn't run branches that passed last time, but still includes them and their last state in the report
    - Doesn't run branches that have since been removed from the tree
    - Runs everything else (new branches/changed branches, branches that failed last time, branches that didn't run last time)
    - Always runs the current hooks, not the hooks from the last run

Reports
    - Where to find the report
    - Pass/fail and expected/unexpected
        - Steps
            - A step passes is no errors are thrown inside of it
            - A step fails if an error is thrown inside of it
            - A step is marked expected if it passes, or unexpected if it fails
                - However, if the step has a # identifier, it will be marked expected if it fails, and unexpected if it passes
                - An error will show up in the report if a step is _unexpected_ (as opposed to passed or failed)
                - Give an example of using #: a step fails, you file a defect, put in # and comment with bug tracker number so the
                    test doesn't keep bothering you (it may be a low priority defect that isn't being fixed yet). Once it's fixed,
                    the step will unexpectedly pass (and the branch will fail), you will notice, close off the bug tracker defect, and
                    remove the # and comment.
        - Branches
            - A branch will pass if all steps are as expected
            - A branch will fail if one or more steps are unexpected
        - Error.continue
            - If the error obj thrown inside a step has error.continue set to true, the branch will continue executing, though it will still fail
                if there is one or more unexpected errors
            - If error.continue isn't set to true, and if the error was unexpected, the step will be marked as an unexpected fail, the branch will
                be failed immediately, and all other branches that go through that step will be automatically skipped (there's no point in repeating steps that are doomed to fail)
        - Timeouts are set by each step on a case-by-case basis
    - Reading stack traces in errors
        - Error of step = filename and line number in filename
        - Stack trace = at CodeBlock_for_[NAME OF CODE BLOCK FUNCTION] (eval at ...), <anonymous>:[LINE NUMBER]:[COL NUMBER])
            - [LINE NUMBER] is the line in the file containing [NAME OF CODE BLOCK FUNCTION]
        - Implement complex functions in their own js files to generate more traditional stack traces
    - Sample screenshot and summary
    - What's in a name?
        The only real way to name a test is to concatenate the steps together, as tests are detailed and many of them differ by
        just one step. When you name a test, you're really just providing a crude summary of one of the steps towards the end.
        Really, naming is useless and only slows you down.

Step blocks
    - Vertical list of 2 or more steps, no blank lines in between
    - Must end in an empty line if it has children
    - Show examples
    - Each line of a step block will connect with every child step to the step block, in a separate branch. It's kind of like a for loop.
        - Give an example
    - .. at the top of a step block means sequential execution. Kind of like if we indented every step into a tree.
        - .. must be at the same indentation as vertical list
        - Function in the list with multiple branches will cause the list to branch (give example - like the one in the Hooks section below)

Textual steps (-)

Step reference
    - From built-in packages
    - Browsers, Webdriver steps, Verify, Assertions, Wait, etc.
    - Mocking APIs (it has its own section too)

Code reference
    - JS functions available as part of built-in packages
    - execInBrowser()
    - Timeout code

ElementFinders
    - [OPTIONAL(1st/2nd/3rd/etc.)   MANDATORY('TEXT' AND/OR VAR-NAME)   OPTIONAL(next to 'TEXT')]
    - Examples
        - [ 'Login' box ]
        - [ 'Login' ]
            - Any element that's an a, button, input, textarea, etc.  or is clickable/has a click handler and contains text 'Login' (see SmashPANEL implementation)
        - [ 'Login' box next to 'foo' ]
        - [ box next to 'foo' ]
        - [ box ] (although you could use {box} too)
        - [ 4th 'Login' box ]
        - [ 4th 'Login' next to 'foo' ]
    - Explain the basics of the find algorithm
    - May contain vars
        - [ {{N}}th 'some {text}' next to '{{something}}' ]
            Note: "th" can be applied to any number

Functions
    - Calling
        - Examples of calls (include {vars}, {{vars}}, 'strings', "strings", [strings], and vars inside of strings)
        - Vars and strings designate parameter inputs in a function call
        - Function {{var}} here OR Function "6" here OR Function ['element' finder] here maps to * Function {{other var}} here
            - All function inputs are either {vars}, {{vars}}, 'strings', "strings", or [strings]
            - {{vars}} in a function declaration must all be {{local}}, not {global}
        - Finds closest matching function declaration in the tree, otherwise looks to packaged functions
        - When a *function ends in multiple leaves, those are separate branches for the indented line below function call
            - Show example
    - Declaring
        - Examples of declarations
        - {{local vars}} designate parameters in a function declaration
        - Finding declaration
            - First look to siblings, then to siblings of parent, etc.
            - Match custom functions first, then primitive packaged functions
            - Don't forget about functions declared within function F. A call to F makes the functions accessible to its children
                - Functions and {vars} declared inside a function are accessible to children of the caller step
    - Functions are case insensitive, leading and trailing whitespace is ignored, and whitespace in the middle is always treated as a single space
    - Examples
        - Using functions to encapsulate common steps
        - Using functions to enumerate branches (like a step block but with multiple levels, or the whole {x}=F thing)
        - Using functions to organize testing (have a high-level tree that describes your app, where each leaf is a function call to a function with multiple branches, where all the testing for that specific component occurs)
        - Use this function in a test, and it will automatically split into two branches, each of which tests a different way to get to the same place
            * Select beans and rice
                Variant 1 - ..
                    Click Beans
                    Click Rice

                Variant 2 - ..
                    Click Rice
                    Click Beans

                (Also useful for "Get to page X", where you can either click a link or enter a url)
        - On Page X pattern, with verifications and setting global vars to selectors in a .. step block
    - Pitfalls
        - Since strings and vars designate inputs, always use \', \", \[, \] when using those actual characters inside a step's text or in a string, to prevent a parameter from forming

Variables
    - Types of vars
        - {var} is global
            - Exists for the life of the branch
            - Steps below where {var} is declared will have access to {var}, which includes inside function calls
            - If {var} is declared inside a function, it will be accessible in the caller after the function call step
            - Accessible within Every Branch/Step hooks, for hooks that apply to branches where the var was declared
        - {{var}} is local (internal to the function)
            - Goes out of scope at the end of the function and is not accessible within function calls inside the function declaration
            - A local var is accessible inside the code block of a non-function-call step ( Text {code block} )
    - Where to use them (they are replaced with their value)
        - Function call
            F {var1} {{var2}}
        - String literal
            'string literal {var1}', "string literal {{var2}}", or [string literal {var3}]
    - Setting vars
        - {var} = 'String' (or "String" or [String])
            - To clone a var, use {var}='{var2}'
            - {var1}='str1', {var2}='str2', etc.
                - When setting multiple vars in a single line, use commas to separate them. Strings only. No functions.
        - {var} = Function with a code block
            - Code Function returns a string (actually any kind of js value will work)
            - Could be {var} = Text { code block that returns something }
        - {var} = Function with branches
            - Each line must be {x}='value' (or "value" or [value])
                - No children
            - Separate branches will be created, each setting {var} to each 'value' encountered to the right of {x}
            - You can name {x} whatever you want, but the convention is {x}
    - Lookahead
        - {vars} that will be defined later in the branch
        - Allows you to refactor common steps higher up into the tree. Provide an example with different {usernames}.
        - You cannot set a lookahead {var} = Function, where the Function returns async
        - You cannot set a lookahead var inside a function's code block (via var=something or setGlobal()/setLocal()). Must be {var}='value'.
    - Variables are case insensitive, leading and trailing whitespace is ignored, and whitespace in the middle is always treated as a single space
        - Case sensitive as js vars and in persistent/global/local though (use the case that was used when declared - though leading and trailing whitespace is ignored too)
    - Pitfalls
        - Cannot have a \ in the name of a variable

Comments
    - // only, stuff before it is a legit step
    - If whole line starts with //, it's ignored as if it weren't there
        - For example
            A
            // B
            C
                is still a step block, with members A and C

Code blocks
    - Types
        - * Function {code}
        - Textual step {code} or Textual step - {code}
    - Code blocks end on a line that starts with '}' and is the exact number of indents as the step that started the code block
    - +, .., etc. characters applied come after the step text and before the {
    - Only lines after the { line and before the } count as part of the code block
    - Variables
        - Get
            - {{var1}} is var1 or getLocal("var1")
            - {var2} is var2 or getGlobal("var2")
            - persistent vars persist from branch to branch, for the life of the whole test run and are only accessible via getPersistent("var3")
            - More on js vars
                - When persistent, global, and local vars share the same name, the js var will be set according to this precedence: local, global, persistent
                - Vars whose names have anything but [A-Za-z0-9\-\_\.] won't be converted to js vars
                - Vars whose names are a reserved js keyword won't be converted to js vars
        - Set
            - {{var1}} is setLocal("var1", "value") (NOTE: you can't set var1=value as this will not persist past the end of the code block)
            - {var2} is setGlobal("var2", "value")
            - persistent vars: setPersistent("var3", "value")
    - Access RunInstance object via runInstance variable
    - Pitfalls
        - Don't use a var in a js code block that's set in a later step. That trick only works for {vars} that are used and set outside of code blocks.
        - Don't set a variable by using varname= when you want that value to persist beyond the end of the code block. Use setter functions (i.e., setLocal(), setGlobal(), setPersistent()) instead.

Sequential execution (..)
    - .. at the end of a step
        - .. means execute branches at and below me depth-first sequentially
            - The steps at and below a .. are expanded normally, then executed sequentially
            - ..'es have the effect of flattening themselves and their children into one long list of sequentially indented steps
        - Give examples

            Something - ..
                One -
                    Two -
                    Three -
                Four -
                    Five -

                is

                1) Something
                2) One
                 etc.

            Test the editbox without navigating off the page ..

                Enter bad value 1
                Enter bad value 2
                Enter bad value 3

                    Verify error

        - a .. inside a *Function declaration does not expand beyond the bounds of that *Function declaration
        - If a function call is at or below the .. line, and it has multiple branches inside, the multiple branches will
            be combined sequentially.
            - Give an example

                Test the editbox without navigating off the page ..
                    Enter bad values
                        Verify error

                    * Enter bad values
                        Enter bad value 1
                        Enter bad value 2
                        Enter bad value 3

    - .. above a step block
        - Acts differently from the .. that comes at the end of a line
        - Only applies to the step block, not to the step block's children
        - If step block contains a function with multiple branches, the multiple branches won't be combined sequentially as with the
            .. at the end of a step. Rather, multiple branches will be generated.
            - Give an example
                ..
                Add item to cart
                Go to cart page
                Verify something on cart

                * Go to cart page  // Two different ways of getting to the cart
                    Navigate to '/cart'

                    Click {cart button in header}

    - Show more examples from bottom of test_language_sample.txt

No parallel execution (+)
    - No two child branches may execute simultaneously

Expected failure (#)
    - #
    - Recommended to put a comment after the #, linking to a bug tracker ticket, etc.

To-Do (-T)
    - Marks this step and those under it as todo
    - Treated as a textual step
    - Only one branch going through this step will be run, the rest will be skipped as repeats

Manual tests (-M)
    - Marks this step and those under it as manual
    - Treated as textual step, but you can ask to generate manual checklist from command line
    - Only one branch going through this step will be run, the rest will be skipped as repeats

Only ($)
    - $ = Only run branches under this step, but no debugging.
        - Show example. Comes at the start of the step, including before a function declaration's *.
        - Multiple $'s with the same parent (on the same indent level) only run branches that fall under one of these branches (OR)
        - You can put $'s at different levels to isolate a branch or branches
        - Give more examples

Debug (~)
    - Debug identifier (~)
        - Show example. Comes at the start of the step, including before a function declaration's *.
    - Isolates a single branch and pauses right before the step marked ~ and opens up the REPL
    - Pauses right after a step if it fails (or unexpectedly passes)
    - Use multiple $'s and ~'s to isolate a single branch to debug (or you can use multiple ~'s)

REPL
    - Using REPL
    - Kicking off blank browser and REPL just from the command line (- REPL)

Selective test running
    - Only identifier ($)
    - Groups
        - Choosing which groups to run from variable, or from command line
        - When multiple group vars are set in a branch, the branch belongs to all groups
    - Frequency
        - Choosing which frequencies to run from {frequency}='high/med/low', or from command line
            - You can choose to run tests from a frequency, and above
        - The value of {frequency} at the leaf is what controls the frequency of that branch
        - Branches are also run in order of frequency, from high to low, where no frequency is med
        - Recommended to sort the children of a step by their frequency
    - When noDebug command line flag is set, a ~ or $ anywhere in your tree will cause an error
        - Great for making sure you're not debug prior to committing test files to CI

Stubbing out APIs
    - Examples
        - Use packaged sinon-injecting js function
        - Stubs out XHR
            - https://sinonjs.org/releases/latest/fake-xhr-and-server/
            - Give examples of a few GET/POST routes and their responses
        - Restores original XHR once test is over

Hooks
    - Piece of code that runs at certain points. Not for testing. For internal stuff, like reporting, requires,
        js function declarations, screenshotting, logging, etc.
    - * Before Every Branch
        - runs before every branch that goes through this function declaration's parent
    - * After Every Branch
        - runs after every leaf under this function declaration's parent
    - * Before Every Step
    - * After Every Step
        - Examples
            - Taking a screenshot
    - * Before Everything
        - before any branches begin, execute this
        - only valid at 0 indents
        - applies to all branches from all files you put in your glob
        - Examples
            - setInterval() that runs in the background and checks for a popup, then closes it
            - require() in a library (figure out how to do this)
    - * After Everything
        - after all branches end, execute this
        - only valid at 0 indents
        - applies to all branches from all files you put in your glob
    - Code blocks only. They cannot have children.
    - You're not allowed to have any identifiers (~, $, .., -T, etc.) on them
    - Hooks won't have a pass/fail state. If a hook fails, the step/branch it corresponds to will take the error.
    - These are recommended for internal framework stuff, like reporting (so you can run this code whether or not the step failed)
        - Setup/teardown too, though that should really be part of the test itself
            i.e.,
            My Test -
                ..
                Setup (teardown should really be here, so each test has a clean slate)
                Steps
                Teardown

            * Setup
                A (includes the same login as teardown, to clear out old state)

            * Steps
                B
                    C
                D

            * Teardown
                E

Packages
    - Just create a file with a * Before Everything that injects what it needs. Then just distribute this file and have users
        put it into packages/
    - Give some examples
        - Show injection being made into Runner.persistent.packageName
