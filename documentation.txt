What is SmashTEST?
    - Generates and executes functional, (?)(load, and security tests) from a test tree
        - Geared towards UI browser testing, but can be used for anything
        - NodeJS for now
    - Example
    - Easier to create tests as a tree, makes you think of all permutations on a single page or input.
        Represents how a tester comes up with test cases (tester thinks breadth-first, user thinks depth-first).

Setup
    - Installation
        - npm
        - Use even-numbered version of nodejs
        (?) - Install webdriverjs and/or selenium separately? See webdriverjs installation guide and try to install it as a dependency
    - Installing SmashPANEL Lite too
        - What it does and why it's recommended

Steps
    - Textual steps, built-in steps, functions
    - Each "branch" is a separate test. We call tests "branches".
    - Indents
        - 4 spaces for indents (no tabs)
        - Like indented comments on a site like Reddit, where each chain of replies is a branch
    - Blank lines generally don't matter
        - Use them for stylistic organization and to group similar steps
        - Recommended to put a blank line above and below a step block, to make it easier to see.
        - You can also use blank lines to prevent a step block from forming, since step blocks require consecutive lines
    - Pitfalls
        - Always use \' or \" when the same line has 'strings' or "strings".
            - ' and \', and " and \" will match each other, but you should use \' and \" to prevent a string literal from forming in a function call

Running tests
    - Basic command line invocation
        - File glob passed in
            - All files are merged into one big one, and everything at the top level is accessible to everything in other files
        - Setting {vars} from command line
        - Branches are run in order of {frequency}, high to low, where no {frequency} is med
    - If a step irrevokably fails, all other branches that go through that step will be automatically skipped (there's no point in repeating steps that are doomed to fail)

Only run tests that didn't pass last time
    - Doesn't run branches that passed last time
    - Doesn't run branches that have since been removed from the tree
    - Runs everything else (new branches, branches that failed last time, branches that didn't run last time)
    - Runs current hooks, regardless of if they passed or not

Configuration
    - Timeouts
    - Max browser instances

Output
    - Console
    - Report
        - Test failures

Step reference
    - Browsers, Webdriver steps, Verify, Assertions, Wait, etc.
    - Mocking APIs (it has its own section too)
    - Execute in browser {}

Step blocks
    - Vertical list of 2 or more steps, no blank lines in between
    - Must end in an empty line if it has children
    - Show examples
    - Each line of a step block will connect with every child step to the step block, in a separate branch. It's kind of like a for loop.
        - Give an example
    - .. at the top of a step block means sequential execution. Kind of like if we indented every step into a tree.
        - .. must be at the same indentation as vertical list

Textual steps (-)

ElementFinders
    - [OPTIONAL(1st/2nd/3rd/etc.)   MANDATORY('TEXT' AND/OR VAR-NAME)   OPTIONAL(next to 'TEXT')]
    - Examples
        - [ 'Login' box ]
        - [ 'Login' ]
            - Any element that's an a, button, input, textarea, etc.  or is clickable/has a click handler and contains text 'Login' (see SmashPANEL implementation)
        - [ 'Login' box next to 'meow' ]
        - [ box next to 'meow' ]
        - [ box ] (although you could use {box} too)
        - [ 4th 'Login' box ]
        - [ 4th 'Login' next to 'meow' ]
    - Explain the basics of the find algorithm

Functions
    - Calling
        - Examples of calls (include vars, strings, vars within strings, and elementFinders)
        - Function {var} here OR Function "6" here OR Function ['element' finder] here maps to * Function {{other var}} here
            - All function inputs are either {vars}, "strings", or [ElementFinders]
        - Finds closest matching function declaration in the tree, otherwise looks to built-in functions
        - When a *function ends in multiple leaves, those are separate branches for the indented line below function call
            - Show example
    - Declaring
        - Examples of declarations
        - Finding declaration
            - First look to siblings, then to siblings of parent, etc.
            - Match custom functions first, then primitive built-in functions
            - Don't forget about functions declared within function F. A call to F makes the functions accessible to its children
    - Examples
        - Using functions to encapsulate common steps
        - Using functions to enumerate branches (like a step block but with multiple levels, or the whole {x}=F thing)
        - Using functions to organize testing (have a high-level tree that describes your app, where each leaf is a function call to a function with multiple branches, where all the testing for that specific component occurs)
    - Pitfalls
        - Functions must match case (if they don't it's a compile error), but may include varying whitespace

Variables
    - Types of vars
        - {var} is global (steps below the function call will have access to {var})
        - {{var}} is internal to the function (it goes out of scope at the end of the function)
    - Setting vars
        - {var} = 'String' (or "String")
        - {var} = Function with a code block
            - Code Function returns a string (actually any kind of js value will work)
            - Could be {var} = Text { code block that returns something }
        - {var} = Function with branches
            - Each line must be {x}='value'
                - No children
            - Separate branches will be created, each setting {var} to each 'value' encountered to the right of {x}
            - You can name {x} whatever you want, but the convention is {x}
    - In a line that's {var1}=Step1, {var2}=Step2, do not accept Functions* in Step1/2/etc.
        - (In other words, if there are multiple vars being set, each Step must be a string literal)
    - Using {vars} that will be defined later in the branch
        - Allows you to refactor common steps higher up into the tree. Provide an example with different {usernames}.
    - Pitfalls
        - Cannot have a \ in the name of a variable
        - Whitespace in front of and behind a variable name doesn't count

Comments
    - // only, stuff before it is a legit step
    - if whole line starts with //, it's treated as an empty line

Code blocks
    - Types
        - * Function {code}
        - Textual step {code} // - is optional
        - Execute in browser {code}
    - Code blocks end on a line that starts with '}' and is the exact number of indents as the step that started the code block
    - +, .., etc. characters applied come after the step text and before the {
    - Only lines after the { line and before the } count as part of the code block
    - Vars accessible in code as global.name (or global["var name"]) or local.name (or local["var name"])
        - Vars that persist from branch to branch are stored in persistant

Sequential execution (..)
    - .. means execute branches at and below me depth-first sequentially, but never repeat the execution of a parent step (including me)
        more than once
            - ..'es have the effect of flattening themselves and their children into one long list of sequentially indented steps
            - a .. inside a *Function declaration does not expand beyond the bounds of that *Function declaration
            - If a function call is at or below the .. line, and it has multiple branches inside, it will be executed as such:
                - All in one branch: 1st branch from top to bottom, flattened steps under function call, 2nd branch from top to bottom, flattened steps under function call, etc.
                - Give an example
    - .. above a step block
        - Only applies to the step block, not to the step block's children
        - Same rules if one of the steps in the step block is a function with multiple branches
    - Show examples from bottom of test_language_sample.txt

No parallel execution (+)
    - No two child branches may execute simultaneously

Expected failure (#)
    - #
    - Recommended to put a comment after the #, linking to a bug tracker ticket, etc.

To-Do (-T)
    - Marks this step and those under it as todo
    - Treated as a textual step
    - Only one branch going through this step will be run, the rest will be skipped as repeats

Manual tests (-M)
    - Marks this step and those under it as manual
    - Treated as textual step, but you can ask to generate manual checklist from command line
    - Only one branch going through this step will be run, the rest will be skipped as repeats

Only ($)
    - $ = Only run branches under this step, but no debugging.
        - Multiple $'s that intersect only run tests that fall under both (AND)
        - Multiple $'s that do not intersect run tests that fall under either (OR)
        - A $ on one or more step block members will remove all other step block members

Debug (~)
    - Debug identifier (~)
    - Use multiple $'s and a ~ to isolate a single branch to debug (or you can use multiple ~'s)
    - When multiple branches are marked with ~'s, it chooses the first one
    - Works inside hooks, but will only isolate a branch inside that hook (won't affect normal branches)
    - Throws exception if a ~ exists, but is cut off due to $, groups, or frequency
    - maxInstances must be 1 if a ~ exists anywhere
    - pauseOnFail command line flag will pause if a step fails and open up the REPL
        - maxInstances must be set to 1 (because multiple browsers will be unmanageable)

REPL
    - Using REPL
    - Kicking off blank browser and REPL just from the command line

Selective test running
    - Only identifier ($)
    - Groups
        - Choosing which groups to run from variable, or from command line
        - When multiple group vars are set in a branch, the branch belongs to all groups
    - Frequency
        - Choosing which frequencies to run from {frequency}='high/med/low', or from command line
            - You can choose to run tests from a frequency, and above
        - The value of {frequency} at the leaf is what controls the frequency of that branch
        - Branches are also run in order of frequency, from high to low, where no frequency is med
        - Recommended to sort the children of a step by their frequency
    - When noDebug command line flag is set, a ~ or $ anywhere in your tree will cause an error
        - Great for making sure you're not debug prior to committing test files to CI

Mocking APIs

Hook steps
    - * After Every Branch
        - {successful} = true if passed, false if failed
        - {error} = the Error object, if failed
        - attached to the end of every leaf under this function declaration's parent
        - For "Before Every Branch", just insert a step on top of all the branches you want to cover
    - * After Every Step
        - {successful} = true if passed, false if failed
        - {error} = the Error object, if failed
    - * Before Everything
        - before any branches begin, execute this
        - only valid at 0 indents
        - applies to all branches from all files you put in your glob
    - * After Everything
        - after all branches end, execute this
        - only valid at 0 indents
        - applies to all branches from all files you put in your glob
    - Hook steps won't have a pass/fail state. They're not there to verify, they're there to setup/teardown/report.
    - Their execution is just repetitive background, and any failures are noted as from a hook and put into the current branch/step
