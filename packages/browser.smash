// ***************************************
//  Hooks
// ***************************************

*** After Everything {
    if(typeof BrowserInstance != 'undefined') {
        await BrowserInstance.killAllBrowsers(runInstance.runner);
    }
}

// ***************************************
//  Open browsers
// ***************************************

* Open Chrome {
    await i('BrowserInstance', './js/browserinstance.js')
        .create(runInstance)
        .open({name: 'chrome'});
}
    Use browser +?

* Open Firefox {
    await i('BrowserInstance', './js/browserinstance.js')
        .create(runInstance)
        .open({name: 'firefox'});
}
    Use browser +?

* Open Safari {
    await i('BrowserInstance', './js/browserinstance.js')
        .create(runInstance)
        .open({name: 'safari'});
}
    Use browser +?

* Open IE {
    await i('BrowserInstance', './js/browserinstance.js')
        .create(runInstance)
        .open({name: 'internet explorer'});
}
    Use browser +?

* Open Edge {
    await i('BrowserInstance', './js/browserinstance.js')
        .create(runInstance)
        .open({name: 'MicrosoftEdge'});
}
    Use browser +?

* Open browser {{name}} {
    await i('BrowserInstance', './js/browserinstance.js')
        .create(runInstance)
        .open({name: name});
}
    Use browser +?

// ***************************************
//  Browser-dependent functions
// ***************************************

// Note: functions under Use browser are indented because they're only available after a Use browser call

* Use browser

    // ***************************************
    //  Hooks
    // ***************************************

    *** Before Every Step {
        if(typeof browser != 'undefined') {
            await browser.takeScreenshot(false);
        }
    }

    *** After Every Step {
        if(typeof browser != 'undefined') {
            await browser.takeScreenshot(true);
        }
    }

    *** After Every Branch {
        if(typeof browser != 'undefined') {
            await browser.clearUnneededScreenshots();
            await browser.close();
        }
    }

    // ***************************************
    //  Window
    // ***************************************

    * Set dimensions to width={{width}} height={{height}} {
        await browser.driver.manage().window().setRect({ width: parseInt(width), height: parseInt(height) });
    }

    * Maximize window {
        await browser.driver.manage().window().maximize();
    }

    // ***************************************
    //  Actions
    // ***************************************

    * Navigate to {{url}} {
        await browser.nav(url);
    }

    * Nav to {{url}} {
        await browser.nav(url);
    }

    * Click {{element}} {
        await $(element).click();
    }

    * Double click {{element}} {
        await browser.driver.actions().doubleClick(await $(element)).perform();
    }

    * Hover over {{element}} {
        await browser.driver.actions().mouseMove(await $(element)).perform();
    }

    * Scroll to {{element}} {
        await browser.driver.actions().move({origin: await $(element)}).perform();
    }

    // Returns JSON object representing cookie
    * Get cookie {{name}} {
        return await browser.driver.manage().getCookie(name);
    }

    * Set cookie {{name}} to {{value}} {
        await browser.driver.manage().addCookie({name: name, value: value});
    }

    * Set cookie {{name}} to {{value}}, expiring in {{exp}} secs {
        await browser.driver.manage().addCookie({
            name: name,
            value: value,
            expiry: new Date(Date.now() + (exp * 1000))
        });
    }

    * Delete cookie {{name}} {
        await browser.driver.manage().deleteCookie(name);
    }

    * Delete all cookies {
        await browser.driver.manage().deleteAllCookies();
    }

    * Clear local storage {





    }

    * Clear cache and cookies {
        // including local storage





    }

    * Go Back {





    }

    * Go Forward {





    }

    * Refresh {






    }

    * Type {{text}} into {{element}} {
        // sendkeys, you can also use unicode codes for special keys like arrows (represented as "[enter]", etc.)
        /*
        - Enter '[none]', Select '[none]', etc. just does nothing, without an error
            - This allows you to Enter, Select, etc. a variable, that can sometimes be set to [none] to signify ignoring this form field
            - Make sure you can escape using \[none\]. Same thing with keys like [enter].
        */







    }

    * Clear {{element}} {
        // clears the given element, a text input or a textarea





    }

    * Set {{element}} to {{value}} {
        // can be textbox, dropdown, etc. (anything with a value)
        // support [none]





    }

    * Check {{element}} {
        // checkboxes or radio






    }

    * Uncheck {{element}} {
        // checkboxes or radio





    }

    * Select {{value}} from {{element}} {
        // dropdown, where value is exact text, or nearest text with a warning logged (via log())
        // support [none]





    }

    * Current url {
        // return current absolute url





    }

    * Window title {
        // returns window title





    }

    * Value of {{element}} {
        // returns value of element





    }

    * Open new tab {







    }

    * Switch to tab with title {{text}} {
        // window title contains given text





    }

    * Switch to tab with url {{url}} {
        // search for full url, then do partial matches






    }

    * Switch to the {{nth}} tab {
        // nth in an actual ordinal (strip out the number from this string)





    }

    * Switch to iframe {{element}} {
        // element is an ElementFinder of an iframe





    }

    * Switch to original iframe {
        // parentFrame aka defaultContent





    }

    // ***************************************
    //  Network conditions and throttling (Chrome only)
    // ***************************************

    * Offline {
        // ChromeDriver only (throw error if not Chrome). driver.setNetworkConditions()



    }

    * Online {
        // ChromeDriver only (throw error if not Chrome). driver.setNetworkConditions()



    }

    * Network latency of {{n}} ms {
        // ChromeDriver only (throw error if not Chrome). driver.setNetworkConditions()



    }

    * No network latency {
        // ChromeDriver only (throw error if not Chrome). driver.setNetworkConditions()



    }

    * Maximum download speed of {{n}} Kbps {
        // ChromeDriver only (throw error if not Chrome). driver.setNetworkConditions()



    }

    * No maximum download speed {
        // ChromeDriver only (throw error if not Chrome). driver.setNetworkConditions()



    }

    * Maximum upload speed of {{n}} Kbps {
        // ChromeDriver only (throw error if not Chrome). driver.setNetworkConditions()



    }

    * No maximum upload speed {
        // ChromeDriver only (throw error if not Chrome). driver.setNetworkConditions()



    }

    // TODO: Alert-related functions

    * Wait {{n}} second
        Wait {{n}} seconds +?

    * Wait {{n}} seconds {
        return new Promise(res => setTimeout(res, n * 1000));
    }

    // ***************************************
    //  Geolocation spoofing
    // ***************************************

    * Location is latitude={{latitude}} longitude={{longitude}} {
        // TODO: https://stackoverflow.com/questions/8411816/how-do-i-enable-geolocation-support-in-chromedriver



    }

    // ***************************************
    //  Mock
    // ***************************************

    * Mock time to {{date}} {
        await browser.mockTime(date instanceof Date ? date : new Date(date));
    }

    * Stop all mocks {
        await browser.mockStop();
    }

    // ***************************************
    //  Verify
    // ***************************************

    * Verify at page {{page}} {
        // page is page title or url (absolute or relative)
        // do a partial match
        // wait for up to 3 secs? (log this)
        // error.continue = true





    }

    * Verify cookie {{name}} contains {{value}} {
        // wait up to 1 sec? (log this)
        // Use webdriver waits



    }

    * Verify {{element}} is visible {
        // wait up to 1 sec? (log this)





    }

    * Verify {{element}} is not visible {






    }

    // ***************************************
    //  Wait until
    // ***************************************

    * Wait until at page {{titleOrUrl}} {
        // wait up to 15 secs (log this)




    }

    * Wait until at page {{titleOrUrl}} (up to {{n}} secs) {





    }

    * Wait until cookie {{name}} contains {{value}} {




    }

    * Wait until cookie {{name}} contains {{value}} (up to {{n}} secs) {




    }

    * Wait until {{element}} is visible {





    }

    * Wait until {{element}} is visible (up to {{n}} secs) {





    }

    * Wait until {{element}} is not visible {





    }

    * Wait until {{element}} is not visible (up to {{n}} secs) {





    }

    // ***************************************
    //  Print and Log
    // ***************************************

    * Log {{text}} {
        log(runInstance.replaceVars(text));
    }

    * {{element}} {
        // Searches for given EF in browser at current moment in time
        // Outputs details to browser's console and number of elements found to regular console
        // Throws error if nothing found or browser isn't open

        if(browser) {
            let ef = new ElementFinder(element, browser.props);
            let results = async ef.find(browser.driver, undefined, undefined, undefined, 0);
            c(`${results.length} elements found. See browser console for details.`);
        }
        else {
            throw new Error(`Browser isn't open`);
        }
    }
