// ***************************************
//  Hooks
// ***************************************

*** After Everything {
    if(typeof BrowserInstance != 'undefined') {
        await BrowserInstance.killAllBrowsers(runInstance.runner);
    }
}

// ***************************************
//  Open browsers
// ***************************************

* Open Chrome {
    await i('BrowserInstance', './js/browserinstance.js')
        .create(runInstance)
        .open({name: 'chrome'});
}
    Use browser +?

* Open Firefox {
    await i('BrowserInstance', './js/browserinstance.js')
        .create(runInstance)
        .open({name: 'firefox'});
}
    Use browser +?

* Open Safari {
    await i('BrowserInstance', './js/browserinstance.js')
        .create(runInstance)
        .open({name: 'safari'});
}
    Use browser +?

* Open IE {
    await i('BrowserInstance', './js/browserinstance.js')
        .create(runInstance)
        .open({name: 'internet explorer'});
}
    Use browser +?

* Open Edge {
    await i('BrowserInstance', './js/browserinstance.js')
        .create(runInstance)
        .open({name: 'MicrosoftEdge'});
}
    Use browser +?

* Open browser {{name}} {
    await i('BrowserInstance', './js/browserinstance.js')
        .create(runInstance)
        .open({name: name});
}
    Use browser +?

// ***************************************
//  Browser-dependent functions
// ***************************************

// Note: functions under Use browser are indented because they're only available after a Use browser call

* Use browser

    // ***************************************
    //  Init
    // ***************************************

    Init +? {
        // Network throttling
        g('isChrome', function() {
            if(browser.params.name.toLowerCase() != 'chrome') {
                log(`Ignoring, since browser isn't chrome`);
                return false;
            }

            return true;
        });

        // Verify/Wait until
        g('VERIFY_TIMEOUT', 1000);
        g('WAITUNTIL_TIMEOUT', 15000);
    }

    // ***************************************
    //  Hooks
    // ***************************************

    *** Before Every Step {
        if(typeof browser != 'undefined') {
            await browser.takeScreenshot(false);
        }
    }

    *** After Every Step {
        if(typeof browser != 'undefined') {
            await browser.takeScreenshot(true);
        }
    }

    *** After Every Branch {
        if(typeof browser != 'undefined') {
            await browser.clearUnneededScreenshots();
            await browser.close();
        }
    }

    // ***************************************
    //  Actions
    // ***************************************

    * Navigate to {{url}} {
        await browser.nav(url);
    }

    * Nav to {{url}} {
        await browser.nav(url);
    }

    * Click {{element}} {
        await (await $(element, true)).click();
    }

    * Native click {{element}} {
        await executeScript(function(element) {
            element.click();
        }, await $(element, true));
    }

    * Double click {{element}} {
        await browser.driver.actions().doubleClick(await $(element, true)).perform();
    }

    * Hover over {{element}} {
        await browser.driver.actions().mouseMove(await $(element, true)).perform();
    }

    * Scroll to {{element}} {
        await browser.driver.actions().move({origin: await $(element, true)}).perform();
    }

    // Returns JSON object representing cookie
    * Get cookie {{name}} {
        return await browser.driver.manage().getCookie(name);
    }

    * Set cookie {{name}} to {{value}} {
        await browser.driver.manage().addCookie({name: name, value: value});
    }

    * Set cookie {{name}} to {{value}}, expiring in {{exp}} secs {
        await browser.driver.manage().addCookie({
            name: name,
            value: value,
            expiry: new Date(Date.now() + (exp * 1000))
        });
    }

    * Delete cookie {{name}} {
        await browser.driver.manage().deleteCookie(name);
    }

    * Delete all cookies {
        await browser.driver.manage().deleteAllCookies();
    }

    * Clear local storage {
        await executeScript(function() {
            localStorage.clear();
        });
    }

    * Clear cookies and local storage
        Delete all cookies +?
            Clear local storage +?

    * Go Back {
        await executeScript(function() {
            window.history.back();
        });
    }

    * Go Forward {
        await executeScript(function() {
            window.history.forward();
        });
    }

    * Refresh {
        await executeScript(function() {
            location.reload(true);
        });
    }

    * Type {{text}} into {{element}} {
        if(text.trim().toLowerCase() == '[none]') {
            log(`Ignoring since text is set to [none]`);
            return;
        }

        await browser.type(text, element);
    }

    * Clear {{element}} {
        await (await $(element, true)).clear();
    }

    * Set {{element}} to {{value}} {
        if(value.trim().toLowerCase() == '[none]') {
            log(`Ignoring since value is set to [none]`);
            return;
        }

        await executeScript(function(elem, value) {
            elem.value = value;
        }, await $(element, true), value);
    }

    * Check {{element}} {
        let elem = await $(element, true);
        try {
            await $(`checked`, undefined, elem); // is elem already checked?
            log(`Ignoring since element is already checked`);
            return;
        }
        catch(e) {
            // Not checked, so click it
            log(`Element is currently not checked, so clicking it`);
            await elem.click();
        }

        try {
            await $(`checked`, undefined, elem); // did the click work?
        }
        catch(e) {
            log(`Click didn't work. Element still unchecked.`);
            throw new Error(`Unable to check element by clicking`);
        }
    }

    * Uncheck {{element}} {
        let elem = await $(element, true);
        try {
            await $(`not checked`, undefined, elem); // is elem already not checked?
            log(`Ignoring since element is already not checked`);
            return;
        }
        catch(e) {
            // Checked, so click it
            log(`Element is currently checked, so clicking it`);
            await elem.click();
        }

        try {
            await $(`not checked`, undefined, elem); // did the click work?
        }
        catch(e) {
            log(`Click didn't work. Element still checked.`);
            throw new Error(`Unable to uncheck element by clicking`);
        }
    }

    * Select {{value}} from {{element}} {
        if(value.trim().toLowerCase() == '[none]') {
            log(`Ignoring since value is set to [none]`);
            return;
        }




        // dropdown, where value is exact text, or nearest text with a warning logged (via log())





    }

    // Returns current abosolute urls
    * Current url {
        return await browser.driver.getCurrentUrl();
    }

    * Window title {
        return await browser.driver.getTitle();
    }

    * Value of {{element}} {
        return await executeScript(function(elem) {
            return elem.value;
        }, await $(element, true));
    }

    // ***************************************
    //  Window
    // ***************************************

    * Set dimensions to width={{width}} height={{height}} {
        await browser.driver.manage().window().setRect({ width: parseInt(width), height: parseInt(height) });
    }

    * Maximize window {
        await browser.driver.manage().window().maximize();
    }

    * Open new tab {
        await executeScript(function() {
            window.open();
        });
    }

    * Switch to window whose title contains {{text}} {
        let windows = await browser.driver.getAllWindowHandles();
        for(let window of windows) {
            await browser.driver.switchTo().window(window);
            let title = await browser.driver.getTitle();
            if(title.includes(text)) {
                log(`Switching to window with title '${title}'`);
                return;
            }
        }

        throw new Error(`Window whose title contains '${text}' not found`);
    }

    * Switch to window whose url contains {{url}} {
        let windows = await browser.driver.getAllWindowHandles();
        for(let window of windows) {
            await browser.driver.switchTo().window(window);
            let windowUrl = await browser.driver.getCurrentUrl();
            if(windowUrl.includes(url)) {
                log(`Switching to window at url '${windowUrl}'`);
                return;
            }
        }

        throw new Error(`Window at url containing '${url}' not found`);
    }

    // Switches windows, where nth in an actual ordinal ('1st', '2nd', etc.)
    * Switch to the {{nth}} window {
        let n = parseInt(nth.replace(/[^0-9]/g, '')) - 1;
        let windows = await browser.driver.getAllWindowHandles();
        if(n >= windows.length) {
            throw new Error(`There is no ${nth} window`);
        }
        await browser.driver.switchTo().window(windows[n]);
    }

    * Switch to iframe {{element}} {
        await browser.driver.switchTo().frame(await $(element));
    }

    * Switch to topmost iframe {
        await browser.driver.switchTo().defaultContent();
    }

    // ***************************************
    //  Alerts
    // ***************************************

    * Accept alert {
        await browser.driver.switchTo().alert().accept();
    }

    * Dismiss alert {
        await browser.driver.switchTo().alert().dismiss();
    }

    * Verify alert contains {{text}} {
        let alertText = await browser.driver.switchTo().alert().getText();
        expect(alertText).to.have.string(text);
    }

    // ***************************************
    //  Network conditions and throttling (Chrome only)
    // ***************************************
    // NOTE: These steps do nothing if browser isn't Chrome

    * Offline {
        if(!isChrome()) {
            return;
        }

        await browser.driver.setNetworkConditions({ offline: true });
    }

    * Online {
        if(!isChrome()) {
            return;
        }

        await browser.driver.setNetworkConditions({ offline: false });
    }

    * Network latency of {{n}} ms {
        if(!isChrome()) {
            return;
        }

        await browser.driver.setNetworkConditions({ latency: parseInt(n) });
    }

    * No network latency {
        if(!isChrome()) {
            return;
        }

        await browser.driver.setNetworkConditions({ latency: undefined });
    }

    * Maximum download speed of {{n}} Kbps {
        if(!isChrome()) {
            return;
        }

        await browser.driver.setNetworkConditions({ download_throughput: parseInt(n) * 1024 });
    }

    * No maximum download speed {
        if(!isChrome()) {
            return;
        }

        await browser.driver.setNetworkConditions({ download_throughput: undefined });
    }

    * Maximum upload speed of {{n}} Kbps {
        if(!isChrome()) {
            return;
        }

        await browser.driver.setNetworkConditions({ upload_throughput: parseInt(n) * 1024 });
    }

    * No maximum upload speed {
        if(!isChrome()) {
            return;
        }

        await browser.driver.setNetworkConditions({ upload_throughput: undefined });
    }

    // ***************************************
    //  Mock
    // ***************************************

    * Mock time to {{date}} {
        await browser.mockTime(date instanceof Date ? date : new Date(date));
    }

    * Mock location to latitude={{lat}} longitude={{long}} {
        await browser.mockLocation(lat, long);
    }

    * Mock location to {{location}} {
        let lat = 0, long = 0;

        switch(location.trim().toLowerCase()) {
            case 'berlin':
                lat = 52.520007, long = 13.404954;
                break;
            case 'london':
                lat = 51.507351, long = -0.127758;
                break;
            case 'moscow':
                lat = 55.755826, long = 37.6173;
                break;
            case 'new york':
                lat = 40.730610, long = -73.935242;
                break;
            case 'mumbai':
                lat = 19.075984, long = 72.877656;
                break;
            case 'san francisco':
                lat = 37.774929, long = -122.419416;
                break;
            case 'seattle':
                lat = 47.608013, long = -122.335167;
                break;
            case 'shanghai':
                lat = 31.230416, long = 121.473701;
                break;
            case 'são paulo':
            case 'sao paulo':
                lat = -23.55052, long = -46.633309;
                break;
            case 'tokyo':
                lat = 35.689487, long = 139.691706;
                break;
            default:
                throw new Error(`The locale '${locale}' is not defined`);
        }

        await browser.mockLocation(lat, long);
    }

    * Stop all mocks {
        await browser.mockStop();
    }

    // ***************************************
    //  Verify
    // ***************************************

    // Verifies browser is currently at page whose title or url contain the given string
    * Verify at page {{titleOrUrl}} {
        await browser.verifyAtPage(titleOrUrl, VERIFY_TIMEOUT);
    }

    * Verify cookie {{name}} contains {{value}} {
        await browser.verifyCookieContains(name, value, VERIFY_TIMEOUT);
    }

    * Verify {{element}} is visible {
        await $(element, undefined, undefined, VERIFY_TIMEOUT, true);
    }

    * Verify {{element}} is not visible {
        await not$(element, undefined, undefined, VERIFY_TIMEOUT, true);
    }

    // ***************************************
    //  Wait until
    // ***************************************

    * Wait until at page {{titleOrUrl}} {
        await browser.verifyAtPage(titleOrUrl, WAITUNTIL_TIMEOUT);
    }

    * Wait until at page {{titleOrUrl}} (up to {{n}} secs) {
        await browser.verifyAtPage(titleOrUrl, n * 1000);
    }

    * Wait until cookie {{name}} contains {{value}} {
        await browser.verifyCookieContains(name, value, WAITUNTIL_TIMEOUT);
    }

    * Wait until cookie {{name}} contains {{value}} (up to {{n}} secs) {
        await browser.verifyCookieContains(name, value, n * 1000);
    }

    * Wait until {{element}} is visible {
        await $(element, undefined, undefined, WAITUNTIL_TIMEOUT, true);
    }

    * Wait until {{element}} is visible (up to {{n}} secs) {
        await $(element, undefined, undefined, n * 1000, true);
    }

    * Wait until {{element}} is not visible {
        await not$(element, undefined, undefined, WAITUNTIL_TIMEOUT, true);
    }

    * Wait until {{element}} is not visible (up to {{n}} secs) {
        await not$(element, undefined, undefined, n * 1000, true);
    }

    // ***************************************
    //  Wait
    // ***************************************

    * Wait {{n}} second
        Wait {{n}} seconds +?

    * Wait {{n}} seconds {
        return new Promise(res => setTimeout(res, n * 1000));
    }

    // ***************************************
    //  Print and Log
    // ***************************************

    * Log {{text}} {
        log(runInstance.replaceVars(text));
    }

    * {{element}} {
        // Searches for given EF in browser at current moment in time
        // Outputs details to browser's console and number of elements found to regular console
        // Throws error if nothing found or browser isn't open

        if(browser) {
            let ef = new ElementFinder(element, browser.props);
            let results = async ef.find(browser.driver, undefined, undefined, undefined, 0);
            c(`${results.length} elements found. See browser console for details.`);
        }
        else {
            throw new Error(`Browser isn't open`);
        }
    }
