<html>
    <head>
        <meta name="tree" content="{{{tree}}}"/>
        <meta name="runner" content="{{{runner}}}"/>
        <meta name="reportTime" content="{{{reportTime}}}"/>
        <meta name="domain" content="{{{domain}}}"/>

        <title>SmashTEST Report</title>

        <link rel="apple-touch-icon" sizes="180x180" href="favicons/apple-touch-icon.png">
        <link rel="icon" type="image/png" sizes="32x32" href="favicons/favicon-32x32.png">
        <link rel="icon" type="image/png" sizes="16x16" href="favicons/favicon-16x16.png">
        <link rel="manifest" href="favicons/site.webmanifest">
        <link rel="mask-icon" href="favicons/safari-pinned-tab.svg" color="#5bbad5">
        <meta name="msapplication-TileColor" content="#da532c">
        <meta name="theme-color" content="#ffffff">

        <script src="https://unpkg.com/popper.js@1"></script>
        <script src="https://unpkg.com/tippy.js@4"></script>

        <script src="https://unpkg.com/react@16/umd/react.development.js" crossorigin></script>
        <script src="https://unpkg.com/react-dom@16/umd/react-dom.development.js" crossorigin></script>
        <script src="https://unpkg.com/babel-standalone@6/babel.min.js"></script>

        <style>
            body {
                background-color: rgb(30,30,30);
                color: white;
                font-family: Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
                margin: 0;
                padding: 0;
            }

            .main {
                outline: 0;
            }

            .header {
                font-size: 16px;
                margin: 0 0 20px 6px;
            }

            .tree-errors .header {
                margin-bottom: 0;
            }

            .pane {
                border: 0;
                margin: 0;
            }

            .tree-pane {
                width: 600px;
                max-width: 50%;
                left: 0;
                padding: 10px 0 10px 8px;
            }

            .tree-pane.full {
                width: 100%;
                max-width: 100%;
            }

            .preview-pane {
                position: fixed;
                top: 0;
                bottom: 0;
                right: 0;
                height: 100%;
                vertical-align: top;
                overflow-y: auto;
                overflow-x: hidden;
                width: calc(100% - 630px);
                min-width: calc(50% - 30px);
                padding: 10px 14px;
                background-color: rgb(45,45,45);
            }

            .preview-pane.hidden {
                display: none;
            }

            .tree-header {
                margin: 0 0 20px 0;
            }

            .tree-header-container {
                margin: 0 0 0 10px;
                font-size: 13px;
            }

            .tree-header-container .msg {
                font-size: 13px;
            }

            .runner-status-msg {
                color: #ffb347;
            }

            .debug-mode {
                margin-left: 30px;
            }

            .branch-list {
                margin: 0 0 30px 0;
            }

            .branch {
                margin-bottom: 30px;
                margin-left: 8px;
                position: relative;
            }

            .branch.active {
                background-color: rgb(45,45,45);
            }

            .branch.hover {
                background-color: rgb(45,45,45);
                /*background-color: rgb(70,70,70);*/
            }

            .branch-indicator {
                display: inline-block;
                position: absolute;
                top: 0;
                left: 0;
                width: 10px;
                height: 100%;
                min-width: 10px;
                border: 0;
                margin: 0;
                padding: 0;
                border-radius: 3px;
                z-index: 3;
            }

            .branch-indicator:hover {
                cursor: pointer;
            }

            .branch-indicator.notrunyet {
                background-color: gray;
            }

            .branch-indicator.running {
                background-color: orange;
                animation: blinker 2s linear infinite;
            }

            @keyframes blinker {
                50% {
                    opacity: 0.3;
                }
            }

            .branch-indicator.passed {
                background-color: green;
            }

            .branch-indicator.failed {
                background-color: red;
            }

            .branch-indicator.skipped {
                background-color: rgb(0,200,200);
            }

            .branch-contents {
                display: inline-block;
                width: 100%;
                border: 0;
                margin: 0;
                padding-left: 10px;
                padding-right: 0;
            }

            .line {
                font-size: 14px;
                position: relative;
                white-space: nowrap;
                cursor: pointer;
                overflow-x: auto;
                overflow-y: hidden;
                padding-right: 20px;
                /*padding: 1px 20px 1px 0;*/
            }

            .line::-webkit-scrollbar {
                display: none;
            }

            .line.active {
                background-color: rgb(45,45,45);
            }

            .line:hover {
                background-color: rgb(45,45,45);
                /*background-color: rgb(70,70,70);*/
            }

            .line .line-container {
                display: inline-block;
            }

            .line .content {
                display: inline-block;
            }

            .line .location {
                display: inline-block;
                vertical-align: top;
                color: transparent;
                padding: 0 30px;
                font-size: 13px;
            }

            .line:hover .location {
                color: rgb(90,90,90);
            }

            .pill {
                position: relative;
                top: -2px;
                color: white;
                padding: 1px 3px;
                border-radius: 5px;
                font-size: 11px;
                margin: 0 10px;
            }

            .pill.skipped {
                background-color: rgb(0,200,200);
            }

            .pill.running {
                background-color: orange;
            }

            .tooltip-text {
                font-size: 12px;
            }

            .tooltip-text.keystrokes {
                text-align: left;
                padding: 5px;
                white-space: pre;
                line-height: 1.7;
            }

            .tree-header-item {
                margin-bottom: 5px;
            }

            .progress-bar {
                height: 20px;
                max-width: 560px;
                margin: -6px 10px 15px 0;
                padding-right: 20px;
            }

            .progress-bar .filled-bar {
                background-color: rgb(245,155,0);
                color: white;
                text-align: center;
                height: 100%;
                border-radius: 4px;
                overflow-x: hidden;
            }

            .progress-bar .filled-bar.paused {
                background-color: rgb(70,70,70);
            }

            .progress-bar .filled-bar-text {
                position: relative;
                top: 2px;
                padding: 0 5px;
            }

            .msg {
                color: rgb(100,100,100);
                font-size: 12px;
                font-weight: normal;
            }

            .notrunyet-item {
                color: gray;
            }

            .running-item {
                color: orange;
                animation: blinker 2s linear infinite;
            }

            .running-item-no-anim,
            .orange-item {
                color: orange;
            }

            .passed-item {
                color: rgb(0,200,0);
            }

            .failed-item {
                color: red;
            }

            .skipped-item {
                color: rgb(0,200,200);
            }

            .counts {
                line-height: 16px;
            }

            .line-index {
                color: rgb(100,100,100);
                font-size: 11px;
                display: inline-block;
                vertical-align: top;
                position: relative;
                top: 2px;
                margin: 0 8px;
            }

            .vertical-line-container {
                border-left: 1px dashed rgb(90,90,90);
                margin-left: 4px;
                padding-left: 9px;
                display: inline-block;
            }

            .line > .vertical-line-container {
                position: relative;
                top: 1px;
                margin-bottom: 1px;
            }

            .collapse {
                filter: invert(40%);
            }

            .collapse.plus {
                position: relative;
                top: 2px;
                width: 13px;
                height: 13px;
                left: -2px;
                margin-right: 1px;
            }

            .collapse.minus {
                position: relative;
                top: 1px;
                width: 13px;
                height: 12px;
                left: -2px;
                margin-right: 1px;
            }

            .collapse:hover {
                filter: invert(60%);
            }

            .collapse-placeholder {
                display: inline-block;
                width: 14px;
            }

            .stacktrace {
                padding: 10px 0 25px 30px;
                color: rgb(220,220,220);
                font-size: 12px;
                white-space: pre;
            }

            .tree-errors .stacktrace {
                overflow-x: auto;
                margin-right: 10px;
            }

            .branch-error .stacktrace {
                overflow-x: auto;
                margin-right: 20px;
            }

            .preview-pane .stacktrace {
                padding: 0 30px 15px;
                overflow-x: auto;
            }

            .line .stacktrace {
                padding: 5px 0 8px 30px;
            }

            .logs {
                padding: 5px 0 20px 20px;
                color: rgb(110,110,110);
                font-size: 12px;
            }

            .log-line {
                margin-bottom: 7px;
            }

            .thumbs-up {
                cursor: default;
            }

            .preview-pane .close {
                display: inline;
                position: absolute;
                top: 0;
                right: 0;
                color: rgb(110,110,110);
                font-size: 30px;
                cursor: pointer;
                padding: 10px 24px 0 0;
            }

            .preview-pane .close:hover {
                color: rgb(150,150,150);
            }

            .preview-pane .preview-name {
                margin-bottom: 10px;
            }

            .preview-pane .preview-state .location {
                color: rgb(110,110,110);
                font-size: 12px;
                margin-left: 20px;
            }

            .preview-pane .preview-name .elapsed {
                color: rgb(110,110,110);
                font-size: 12px;
            }

            .preview-pane .preview-state {
                margin-left: 20px;
                font-size: 13px;
            }

            .preview-pane .msg {
                color: rgb(110,110,110);
                margin-top: 10px;
                margin-left: 20px;
                font-size: 13px;
            }

            .preview-pane .msg.updates-paused {
                background-color: rgb(90,90,90);
                border: 1px solid rgb(90,90,90);
                padding: 1px 7px;
                border-radius: 6px;
                display: inline-block;
                color: rgb(45,45,45);
                font-size: 0.75em;
            }

            .preview-pane .preview-divider {
                margin-bottom: 30px;
            }

            .preview-pane .preview-state .pill {
                position: relative;
                top: -1px;
                cursor: pointer;
            }

            .preview-pane .commandline-hint {
                margin-left: 20px;
                font-size: 12px;
                cursor: pointer;
            }

            .step-report {
                margin: 20px;
            }

            .preview-pane-msg {
                color: rgb(90,90,90);
                font-size: 18px;
                padding-top: 70px;
                text-align: center;
            }

            .preview-section {
                margin: 0 0 30px 0;
            }

            .none-indicator {
                color: rgb(110,110,110);
                font-size: 13px;
                margin-left: 20px;
            }

            .keystroke-command {
                opacity: 0.4;
            }

            #notification {
                visibility: hidden;
                position: fixed;
                text-align: center;
                top: 30px;
                left: 0;
                right: 0;
                z-index: 4;
            }

            #notification .notification-text {
                min-width: 250px;
                background-color: #333;
                color: #fff;
                border-radius: 2px;
                padding: 16px;
                font-size: 17px;
                border-radius: 5px;
            }

            #notification .notification-text .copied-text {
                color: rgb(180,180,180);
            }

            #notification.show {
                visibility: visible;
                -webkit-animation: fadein 0.5s, fadeout 0.5s 2.5s;
                animation: fadein 0.5s, fadeout 0.5s 2.5s;
            }

            @-webkit-keyframes fadein {
                from {top: 0; opacity: 0;}
                to {top: 30px; opacity: 1;}
            }

            @keyframes fadein {
                from {top: 0; opacity: 0;}
                to {top: 30px; opacity: 1;}
            }

            @-webkit-keyframes fadeout {
                from {top: 30px; opacity: 1;}
                to {top: 0; opacity: 0;}
            }

            @keyframes fadeout {
                from {top: 30px; opacity: 1;}
                to {top: 0; opacity: 0;}
            }
        </style>
    </head>
    <body>
        <div id="root"></div>

        <script type="text/babel">
            // Tooltips

            let tippyOptions = {
                placement: "right",
                followCursor: true,
                delay: 0,
                animation: "fade",
                arrow: true,
                arrowType: "sharp"
            };

            function wrapTippyContent(content) {
                return `<span class='tooltip-text'>${content}</span>`;
            }

            function wrapTippyContentForKeystrokes(content) {
                return `<div class='tooltip-text keystrokes'>${content.trim()}</div>`;
            }

            function attachPreviewPaneTooltips() {
                tippyOptions.content = wrapTippyContentForKeystrokes(`
up    = previous step
down  = next step
left  = collapse
right = expand
space = toggle before/after
esc   = close preview
h     = copy hash
c     = copy debug command <span class="keystroke-command">smashtest -d=hash</span>
                `);
                let tippyOptionsKeystrokes = Object.assign({}, tippyOptions);
                Object.assign(tippyOptionsKeystrokes, { followCursor: false, placement: "bottom", maxWidth: 1000 } );
                tippy(".preview-pane .commandline-hint", tippyOptionsKeystrokes);
            }

            function attachTreePaneTooltips() {
                tippyOptions.content = wrapTippyContent("Currently running branch");
                tippy(".branch-indicator.running", tippyOptions);

                tippyOptions.content = wrapTippyContent("Branch passed");
                tippy(".branch-indicator.passed", tippyOptions);

                tippyOptions.content = wrapTippyContent("Branch failed");
                tippy(".branch-indicator.failed", tippyOptions);

                tippyOptions.content = wrapTippyContent("Branch skipped");
                tippy(".branch-indicator.skipped", tippyOptions);

                tippyOptions.content = wrapTippyContent("Branch not run yet");
                tippy(".branch-indicator.notrunyet", tippyOptions);
            }

            /**
             * Returns the text of the given step with modifiers attached
             */
            function stepText(step) {
                return (step.frontModifiers ? step.frontModifiers.join(' ') + ' ' : '') +
                step.text.trim() +
                (step.backModifiers ? ' ' + step.backModifiers.join(' ') : '')
            }

            // React Components

            class App extends React.Component {
                constructor() {
                    super();

                    // State
                    this.state = {
                        tree: null,
                        runner: null,
                        reportTime: null,
                        previewedItem: null,
                        port: null,
                        live: true
                    };
                    this.preState = null; // latest data to come from api, held in this variable if updates are paused on a preview
                    this.slowPoll = false; // if true, don't poll the api as frequently since it's down

                    // App's DOM element
                    this.me = null;

                    // Parse in tree
                    let treeContent = document.querySelector("meta[name=tree]").getAttribute("content");
                    let treeJSON = this.unescapeHtml(treeContent);
                    if(!treeJSON.startsWith("\{\{\{")) {
                        this.state.tree = JSON.parse(treeJSON);
                        this.uncollapseSteps(this.state.tree);
                    }

                    // Parse in runner
                    let runnerContent = document.querySelector("meta[name=runner]").getAttribute("content");
                    let runnerJSON = this.unescapeHtml(runnerContent);
                    if(!runnerJSON.startsWith("\{\{\{")) {
                        this.state.runner = JSON.parse(runnerJSON);
                    }

                    // Parse in reportTime
                    this.state.reportTime = document.querySelector("meta[name=reportTime]").getAttribute("content");

                    // Parse in domain
                    this.state.domain = document.querySelector("meta[name=domain]").getAttribute("content");

                    // Bindings
                    this.setUpdateLoop = this.setUpdateLoop.bind(this);
                    this.setLive = this.setLive.bind(this);
                    this.updateData = this.updateData.bind(this);
                    this.updateState = this.updateState.bind(this);
                    this.uncollapseSteps = this.uncollapseSteps.bind(this);
                    this.unescapeHtml = this.unescapeHtml.bind(this);
                    this.setPreview = this.setPreview.bind(this);
                    this.handleKeyDown = this.handleKeyDown.bind(this);
                    this.handleKeyUp = this.handleKeyUp.bind(this);
                    this.isModifierActive = this.isModifierActive.bind(this);
                    this.showNotification = this.showNotification.bind(this);
                    this.copyToClipboard = this.copyToClipboard.bind(this);
                }

                componentDidMount() {
                    if(window.location.href.match(/^https?\:\/\/|report\.html$/)) { // dated reports from reports/ do not update themselves
                        this.setUpdateLoop();
                    }
                    else {
                        this.setState( { live: false } );
                    }

                    this.me.focus(); // focus on myself, so I can start getting keyboard commands
                }

                /**
                 * Starts the loop that polls the api for data updates
                 */
                setUpdateLoop() {
                    // Start update loop
                    const UPDATE_FREQUENCY = 500; // in ms
                    const UPDATE_FREQUENCY_SLOW = 5000; // in ms
                    setTimeout(() => {
                        this.updateData().finally(this.setUpdateLoop);
                    }, this.slowPoll ? UPDATE_FREQUENCY_SLOW : UPDATE_FREQUENCY);
                }

                /**
                 * Sets the report to either live or not live mode
                 */
                setLive(isLive) {
                    if(isLive) {
                        this.slowPoll = false;
                        this.setState( { live: true } );
                    }
                    else {
                        this.slowPoll = true;
                        this.setState( { live: false } );
                    }
                }

                /**
                 * Called when new data has been pulled from the api and the UI might need to get updated
                 */
                updateData() {
                    let self = this;
                    return new Promise((resolve, reject) => {
                        if(this.state.domain) {
                            let xhr = new XMLHttpRequest();
                            xhr.addEventListener("load", () => {
                                let preState = null
                                try {
                                    preState = JSON.parse(xhr.response);
                                }
                                catch(e) {
                                    this.setLive(false);
                                    resolve(); // fail silently
                                    return;
                                }

                                if(!preState) {
                                    this.setLive(false);
                                    resolve(); // fail silently
                                    return;
                                }

                                this.setLive(true);
                                self.preState = preState;
                                self.updateState();
                                resolve();
                            });
                            xhr.addEventListener("error", () => {
                                this.setLive(false);
                                self.updateState();
                                resolve(); // fail silently
                            });

                            xhr.open("GET", `${this.state.domain}/state?file=${encodeURIComponent(window.location.href.replace(/file\:\/\//, ''))}`);
                            xhr.send();
                        }
                        else {
                            resolve();
                        }
                    });
                }

                /**
                 * Updates this.state with the latest data pulled down from the api, if updates aren't currently paused on a preview
                 * @param {Boolean} [force] - If true, updates the state regardless of whether updates are currently paused on a preview
                 */
                updateState(force) {
                    if((!this.state.previewedItem && this.preState) || force) {
                        this.uncollapseSteps(this.preState.tree);
                        this.setState({
                            tree: this.preState.tree,
                            runner: this.preState.runner,
                            reportTime: this.preState.reportTime
                        });
                    }
                }

                /**
                 * Uncollapse steps in the given tree if they have a step underneath that is running or is failed
                 */
                uncollapseSteps(tree) {
                    tree.branches.forEach(branch => {
                        branch.steps.forEach((step, index) => {
                            if(step.isCollapsed && !step.collapseHide) {
                                // If a step is currently running or is failed, set its isCollapsed = false
                                for(let i = index + 1; i < branch.steps.length; i++) {
                                    let s = branch.steps[i];
                                    if(s.level <= step.level) {
                                        break;
                                    }

                                    if(s.isRunning || s.isFailed) {
                                        step.isCollapsed = false;
                                        break;
                                    }
                                }
                            }
                        });
                    });
                }

                /**
                 * Converts the html entities in str into their actual chars
                 */
                unescapeHtml(str) {
                    return str
                        .replace(/&#039;/g, "'")
                        .replace(/&quot;/g, "\"")
                        .replace(/&gt;/g, ">")
                        .replace(/&lt;/g, "<")
                        .replace(/&amp;/g, "&");
                }

                /**
                 * Sets the preview in the preview pane to the given step or branch
                 * @param {Element} previewedItem - Sets the previewed item to this element (which represents a step or a branch). If that same element is already being previewed, the previewed item will be cleared. Clears the previewed item if null.
                 * @param {Boolean} [force] - If true, set the previewed item to previewedItem regardless of what the current previewed item is
                 */
                setPreview(previewedItem, force) {
                    let noPreview = !previewedItem;

                    if(force) {
                        this.setState({
                            previewedItem: previewedItem
                        });
                    }
                    else if(this.state.previewedItem === previewedItem) { // toggle off
                        noPreview = true;
                        this.setState({
                            previewedItem: null
                        });
                    }
                    else { // toggle on
                        this.setState({
                            previewedItem: previewedItem
                        });
                    }

                    if(noPreview) {
                        this.updateState(true);
                    }
                }

                /**
                 * Handles a key down event
                 */
                handleKeyDown(event) {
                    if(this.isModifierActive(event)) {
                        return;
                    }

                    let charCode = event.keyCode || event.which;
                    let charStr = String.fromCharCode(charCode);

                    if(charCode == '37') { // left arrow
                        let [lines, activeIndex] = getActiveIndex();
                        if(activeIndex != -1) {
                            let collapseIcon = lines[activeIndex].querySelector(".collapse.minus");
                            if(collapseIcon) {
                                collapseIcon.click();
                            }
                        }
                    }
                    else if(charCode == '39') { // right arrow
                        let [lines, activeIndex] = getActiveIndex();
                        if(activeIndex != -1) {
                            let collapseIcon = lines[activeIndex].querySelector(".collapse.plus");
                            if(collapseIcon) {
                                collapseIcon.click();
                            }
                        }
                    }
                    else if(charCode == '38') { // up arrow
                        let [lines, activeIndex] = getActiveIndex();
                        let prevIndex = activeIndex - 1;
                        if(activeIndex != -1 && prevIndex >= 0) {
                            lines[prevIndex].click();
                            scrollIntoView(lines[prevIndex]);
                        }
                        event.preventDefault();
                    }
                    else if(charCode == '40') { // down arrow
                        let [lines, activeIndex] = getActiveIndex();
                        let nextIndex = activeIndex + 1;
                        if(activeIndex != -1 && nextIndex < lines.length) {
                            lines[nextIndex].click();
                            scrollIntoView(lines[nextIndex]);
                        }
                        event.preventDefault();
                    }
                    else if(charCode == '32') { // spacebar
                        if(window.onSpacebarDown) {
                            window.onSpacebarDown();
                        }
                    }
                    else if(charStr == 'H') {
                        if(this.state.previewedItem) {
                            let hash = this.state.previewedItem.props.branch.hash;
                            this.copyToClipboard(hash);
                            this.showNotification(`Copied <span class="copied-text">${hash}</span> to clipboard`);
                        }
                    }
                    else if(charStr == 'C') {
                        if(this.state.previewedItem) {
                            let hash = this.state.previewedItem.props.branch.hash;
                            //let filename = this.state.previewedItem.props.branch.steps[0].filename;
                            //let command = `smashtest ${filename} -d=${hash}`;
                            let command = `smashtest -d=${hash}`;
                            this.copyToClipboard(command);
                            this.showNotification(`Copied  <span class="copied-text">${command}</span> to clipboard`);
                        }
                    }
                    else if(event.key == 'Escape') { // esc key
                        this.setPreview(null);
                    }

                    function getActiveIndex() {
                        let lines = document.querySelectorAll(".line");
                        for(let i = 0; i < lines.length; i++) {
                            let line = lines[i];
                            if(line.classList.contains("active")) {
                                return [lines, i];
                            }
                        }

                        return [lines, -1];
                    }
                }

                /**
                 * Handles a key up event
                 */
                handleKeyUp(event) {
                    if(this.isModifierActive(event)) {
                        return;
                    }

                    let charCode = event.keyCode || event.which;

                    if(charCode == '32') { // spacebar
                        if(window.onSpacebarUp) {
                            window.onSpacebarUp();
                        }
                    }
                }

                /**
                 * Returns true if a modifier, such as Shift or Control, is currently active
                 */
                isModifierActive(event) {
                    return event.getModifierState("Shift") ||
                        event.getModifierState("Alt") ||
                        event.getModifierState("Control") ||
                        event.getModifierState("Meta") ||
                        event.getModifierState("Fn") ||
                        event.getModifierState("OS");
                }

                /**
                 * Shows a temporary notification at the top of the page
                 */
                showNotification(msg) {
                    const NOTIFICATION_TIMEOUT = 3000; // ms
                    let notification = document.getElementById("notification");
                    let notificationText = notification.querySelector(".notification-text");
                    notificationText.innerHTML = msg;
                    notification.classList.add("show");
                    this.me.focus();
                    setTimeout(() => notification.classList.remove("show"), NOTIFICATION_TIMEOUT);
                }

                /**
                 * Copies the given text to the clipboard
                 */
                copyToClipboard(text) {
                    if(document.queryCommandSupported && document.queryCommandSupported("copy")) {
                        let textarea = document.createElement("textarea");
                        textarea.textContent = text;
                        textarea.style.position = "fixed";
                        document.body.appendChild(textarea);
                        textarea.select();
                        try {
                            return document.execCommand("copy");
                        }
                        catch (e) {
                        }
                        finally {
                            document.body.removeChild(textarea);
                        }
                    }
                }

                render() {
                    return (
                        <div className="main" tabIndex="0" onKeyDown={this.handleKeyDown} onKeyUp={this.handleKeyUp} ref={elem => this.me = elem}>
                            <div id="notification"><span className="notification-text"></span></div>
                            <TreePane data={this.state} setPreview={this.setPreview}/>
                            <PreviewPane previewedItem={this.state.previewedItem} setPreview={this.setPreview} live={this.state.live}/>
                        </div>
                    );
                }
            }

            function TreePane(props) {
                if(!props.data.tree) {
                    return "";
                }

                let className = `pane tree-pane ${!props.data.previewedItem ? `full` : ``}`;

                return (
                    <div className={className}>
                        <TreeHeader data={props.data}/>
                        <TreeErrors data={props.data}/>
                        <BranchListing branches={props.data.tree.branches} setPreview={props.setPreview} previewedItem={props.data.previewedItem}/>
                    </div>
                );
            }

            function TreeHeader(props) {
                let elapsedText = "";
                let elapsed = props.data.tree.elapsed;
                if(typeof elapsed != undefined && elapsed != -1) {
                    elapsedText = `(${formatElapsed(elapsed)})`;
                }

                let anyFailed = false;
                for(let i = 0; i < props.data.tree.branches.length; i++) {
                    let branch = props.data.tree.branches[i];
                    if(branch.isFailed) {
                        anyFailed = true;
                        break;
                    }
                }

                let runnerStatusElem = null;
                if(props.data.runner.isStopped) {
                    runnerStatusElem = <span>Run stopped {elapsedText}</span>
                }
                else if(props.data.runner.isComplete) {
                    runnerStatusElem = <span>Run completed {elapsedText}</span>;
                }
                else if(props.data.runner.isPaused) {
                    runnerStatusElem = <span>Run paused</span>;
                }
                else { // currently running
                    runnerStatusElem = <span className="running-item">Currently running</span>;
                }

                let totalRunning = 0;
                props.data.tree.branches.forEach(branch => branch.isRunning && totalRunning++);

                let totalNotRunYet = props.data.tree.totalToRun - props.data.tree.complete - totalRunning;

                return (
                    <div className="tree-header">
                        <div className="header">{/*props.data.live ? "Live " : ""*/}SmashTEST Report</div>
                        <div className="tree-header-container">
                            {
                                !props.data.runner.isComplete && !props.data.runner.isStopped ?
                                <ProgressBar decimal={props.data.tree.totalStepsComplete / props.data.tree.totalSteps} paused={/*props.data.runner.isPaused ||*/ props.data.previewedItem}/> :
                                ""
                            }
                            <div className="runner-status-msg tree-header-item">
                                {runnerStatusElem}
                                <span className="debug-mode">
                                    {props.data.tree.isDebug ? "In DEBUG mode (~)" : ""}
                                </span>
                            </div>
                            <div className="counts tree-header-item">
                                {
                                    totalRunning > 0 ?
                                    <span><span className="running-count running-item"> {totalRunning} running</span> | </span> :
                                    ""
                                }
                                {
                                    props.data.tree.passed > 0 ?
                                    <span><span className="passed-count passed-item"> {props.data.tree.totalPassedInReport} passed</span> | </span> :
                                    ""
                                }
                                {
                                    props.data.tree.failed > 0 ?
                                    <span><span className="failed-count failed-item"> {props.data.tree.failed} failed</span> | </span> :
                                    ""
                                }
                                {
                                    props.data.tree.skipped > 0 ?
                                    <span><span className="skipped-count skipped-item"> {props.data.tree.skipped} skipped</span> | </span> :
                                    ""
                                }
                                {
                                    totalNotRunYet > 0 ?
                                    <span><span className="notrunyet-count notrunyet-item"> {totalNotRunYet} not run yet</span> | </span> :
                                    ""
                                }
                                <span className="total-count notrunyet-item"> {props.data.tree.totalInReport} total branches</span>
                            </div>

                            {
                                !props.data.live ?
                                <div className="msg">
                                    This report is a snapshot from a completed run.
                                </div> :
                                ""
                            }
                        </div>
                    </div>
                );
            }

            class ProgressBar extends React.Component {
                constructor() {
                    super();
                    this.state = {
                        showPercentage: true
                    };
                }

                componentDidUpdate() {
                    if(this.filledBarText.scrollWidth > this.filledBar.offsetWidth) { // text doesn't have room
                        this.setState({
                            showPercentage: false
                        });
                    }
                }

                render() {
                    let percentageText = (Math.floor(this.props.decimal * 100)) + "%";
                    let filledBarClass = `filled-bar ${this.props.paused ? "paused" : ""}`;
                    return (
                        <div className="progress-bar tree-header-item">
                            <div className={filledBarClass} style={ {width: percentageText} } ref={(elem) => {this.filledBar = elem} }>
                                <div className="filled-bar-text" ref={(elem) => {this.filledBarText = elem}}>
                                    {this.state.showPercentage ? percentageText : ""}
                                </div>
                            </div>
                        </div>
                    );
                }
            }

            function TreeErrors(props) {
                let errors =
                    props.data.tree.beforeEverything
                    .concat(props.data.tree.afterEverything)
                    .filter(hook => {
                        return hook.error;
                    })
                    .map((hook, index) => {
                        return (
                            <div className="stacktrace" key={index}>
                                {formatStackTrace(hook.error)}
                            </div>
                        );
                    });

                if(errors.length > 0) {
                    return (
                        <div className="tree-errors">
                            <div className="header failed-item">Hook errors</div>
                            {errors}
                        </div>
                    );
                }
                else {
                    return "";
                }
            }

            function BranchListing(props) {
                let branchesRunning = props.branches
                    .filter(branch => branch.isRunning)
                    .map((branch, index) => <Branch key={index} branch={branch} setPreview={props.setPreview} previewedItem={props.previewedItem}/>);
                let branchesFailed = props.branches
                    .filter(branch => branch.isFailed)
                    .map((branch, index) => <Branch key={index} branch={branch} setPreview={props.setPreview} previewedItem={props.previewedItem}/>);
                let branchesPassed = props.branches
                    .filter(branch => branch.isPassed)
                    .map((branch, index) => <Branch key={index} branch={branch} setPreview={props.setPreview} previewedItem={props.previewedItem}/>);
                let branchesSkipped = props.branches
                    .filter(branch => branch.isSkipped)
                    .map((branch, index) => <Branch key={index} branch={branch} setPreview={props.setPreview} previewedItem={props.previewedItem}/>);
                let branchesNotRunYet = props.branches
                    .filter(branch => !branch.isRunning && !branch.isFailed && !branch.isPassed && !branch.isSkipped)
                    .map((branch, index) => <Branch key={index} branch={branch} setPreview={props.setPreview} previewedItem={props.previewedItem}/>);

                return (
                    <div className="branch-listing">
                        {
                            branchesRunning.length > 0 ? (
                                <div className="branch-list">
                                    <div className="header">Branches currently running</div>
                                    {branchesRunning}
                                </div>
                            ) : ""
                        }

                        {
                            branchesFailed.length > 0 ? (
                                <div className="branch-list">
                                    <div className="header">Failed branches</div>
                                    {branchesFailed}
                                </div>
                            ) : ""
                        }

                        {
                            branchesPassed.length > 0 ? (
                                <div className="branch-list">
                                    <div className="header">Passed branches</div>
                                    {branchesPassed}
                                </div>
                            ) : ""
                        }

                        {
                            branchesSkipped.length > 0 ? (
                                <div className="branch-list">
                                    <div className="header">Skipped branches</div>
                                    {branchesSkipped}
                                </div>
                            ) : ""
                        }

                        {
                            branchesNotRunYet.length > 0 ? (
                                <div className="branch-list">
                                    <div className="header">Branches not run yet</div>
                                    {branchesNotRunYet}
                                </div>
                            ) : ""
                        }
                    </div>
                );
            }

            class Branch extends React.Component {
                constructor() {
                    super();
                    this.state = {
                        hovered: false
                    };

                    this.hoverStateOn = this.hoverStateOn.bind(this);
                    this.hoverStateOff = this.hoverStateOff.bind(this);
                    this.toggleActiveState = this.toggleActiveState.bind(this);
                    this.updateCollapsing = this.updateCollapsing.bind(this);
                }

                /**
                 * Speeds up React in large reports by only rendering branches that need to be rendered
                 */
                shouldComponentUpdate(nextProps, nextState) {
                    if(this.state.hovered != nextState.hovered) { // hover state changed
                        return true;
                    }
                    else if(!nextProps.previewedItem) { // nothing will be previewed (need to update whole tree, in case we're running)
                        return true;
                    }
                    else if(this.props.previewedItem && this.props.previewedItem === this) { // this branch was previewed
                        return true;
                    }
                    else if(nextProps.previewedItem && nextProps.previewedItem === this) { // this branch will be previewed
                        return true;
                    }
                    else if(this.props.previewedItem && this.props.previewedItem.props.step &&
                        this.props.branch.steps.includes(this.props.previewedItem.props.step)) { // a step under this branch was previewed
                        return true;
                    }
                    else if(nextProps.previewedItem && nextProps.previewedItem.props.step &&
                        this.props.branch.steps.includes(nextProps.previewedItem.props.step)) { // a step under this branch will be previewed
                        return true;
                    }

                    return false;
                }

                hoverStateOn() {
                    this.setState({
                        hovered: true
                    });
                }

                hoverStateOff() {
                    this.setState({
                        hovered: false
                    });
                }

                toggleActiveState() {
                    this.props.setPreview(this);
                }

                /**
                 * Updates the collapsed/uncollapsed state of lines based on what's running and what has errors.
                 * Chooses the lines that will be hidden by a collapse.
                 */
                updateCollapsing() {
                    let branch = this.props.branch;

                    // Reset collapse vars
                    branch.steps.forEach(step => {
                        delete step.collapseHide;
                        delete step.hasChildren;
                    });

                    branch.steps.forEach((step, index) => {
                        // Set hasChildren for step
                        for(let i = index + 1; i < branch.steps.length; i++) {
                            let s = branch.steps[i];
                            if(s.level <= step.level) {
                                break;
                            }
                            else if(!s.isHidden) {
                                step.hasChildren = true;
                                break;
                            }
                        }

                        // If a step has isCollapsed set, collapse all the steps underneath it
                        if(step.isCollapsed && !step.collapseHide) {
                            for(let i = index + 1; i < branch.steps.length; i++) {
                                let s = branch.steps[i];
                                if(s.level <= step.level) {
                                    break;
                                }

                                s.collapseHide = true;
                            }
                        }
                    });
                }

                render() {
                    let branch = this.props.branch;
                    let previewedItem = this.props.previewedItem;

                    let indicatorClassName = "branch-indicator ";

                    if(branch.isRunning) {
                        indicatorClassName += "running";
                    }
                    else if(branch.isFailed) {
                        indicatorClassName += "failed";
                    }
                    else if(branch.isPassed) {
                        indicatorClassName += "passed";
                    }
                    else if(branch.isSkipped) {
                        indicatorClassName += "skipped";
                    }
                    else {
                        indicatorClassName += "notrunyet";
                    }

                    let error = "";
                    if(branch.error) {
                        error = (
                            <div className="stacktrace">
                                {formatStackTrace(branch.error)}
                            </div>
                        );
                    }

                    let hasLevels = false;
                    branch.steps.forEach(step => step.level > 0 ? hasLevels = true : null);

                    this.updateCollapsing();

                    let lines = branch.steps
                        .filter(step => !step.isHidden || step.isFailed)
                        .map((step, index) =>
                            step.collapseHide ? '' : // do this here and not in filter() in order to preserve line numbering
                            <Line
                                step={step}
                                branch={branch}
                                index={index+1}
                                key={branch.hash + ' ' + step.filename + ' ' + step.lineNumber + ' ' + branch.steps.indexOf(step)}
                                lastIndex={branch.steps.length - 1}
                                setPreview={this.props.setPreview}
                                previewedItem={previewedItem}
                                hasLevels={hasLevels}
                            />
                        );

                    let branchClassName = "branch ";
                    if(this.state.hovered) {
                        branchClassName += "hover ";
                    }
                    if(previewedItem === this) {
                        branchClassName += "active ";
                    }

                    return (
                        <div className={branchClassName}>
                            <div
                                className={indicatorClassName}
                                onMouseOver={this.hoverStateOn}
                                onMouseOut={this.hoverStateOff}
                                onClick={this.toggleActiveState}
                            >
                            </div>
                            <div className="branch-contents">
                                <div className="branch-error">
                                    {error}
                                </div>
                                <div className="steps">
                                    {lines}
                                </div>
                            </div>
                        </div>
                    );
                }
            }

            class Line extends React.Component {
                constructor() {
                    super();
                    this.toggleActiveState = this.toggleActiveState.bind(this);
                }

                surroundByVerticalLineContainers(elem, n) {
                    for(let i = 0; i < n; i++) {
                        elem = this.surroundByVerticalLineContainer(elem);
                    }

                    return elem;
                }

                surroundByVerticalLineContainer(elem) {
                    return (
                        <span className="vertical-line-container">
                            {elem}
                        </span>
                    );
                }

                toggleActiveState(e) {
                    this.props.setPreview(this, e.target.classList.contains("collapse"));
                }

                render() {
                    // Add an &nbsp; in front of the line number depending on the amount of digits in the last step of this branch (so they're all the same length)
                    let index = this.props.index;
                    let indexDigits = index.toString().length;
                    let maxDigits = this.props.lastIndex.toString().length;

                    function getIndexElem(index) {
                        return <span className="line-index">{indexElemSpaces(indexDigits)}{index}</span>;
                    }

                    function indexElemSpaces(i) {
                        if(i < maxDigits) {
                            return <span>&nbsp;{indexElemSpaces(i+1)}</span>;
                        }
                    }

                    let contentClassName = "content ";
                    let pill = "";
                    if(this.props.step.isRunning) {
                        contentClassName += "running running-item";
                        pill = <span className="pill running">RUNNING</span>;
                    }
                    else if(this.props.step.isPassed) {
                        contentClassName += "passed-item";
                    }
                    else if(this.props.step.isFailed) {
                        contentClassName += "failed-item";
                    }
                    else if(this.props.step.isSkipped) {
                        contentClassName += "skipped skipped-item";
                        //pill = <span className="pill skipped">SKIPPED</span>;
                    }
                    else { // not run yet
                        contentClassName += "notrunyet notrunyet-item";
                    }

                    let error = "";
                    if(this.props.step.error) {
                        error = (
                            <div className="stacktrace">
                                {formatErrorMsg(this.props.step.error)}
                            </div>
                        );
                    }

                    let lineClassName = "line ";
                    if(this.props.previewedItem === this) {
                        lineClassName += "active ";
                    }

                    let lineElem = (
                        <span className="line-container">
                            <span className={contentClassName}>
                                <CollapseIcon
                                    step={this.props.step}
                                    hasLevels={this.props.hasLevels}
                                />
                                {stepText(this.props.step)}
                                {pill}
                            </span>
                            <span className="location">[{this.props.step.filename}:{this.props.step.lineNumber}]</span>
                            {error}
                        </span>
                    );
                    lineElem = this.surroundByVerticalLineContainers(lineElem, this.props.step.level);

                    return (
                        <div className={lineClassName} onClick={this.toggleActiveState}>
                            {getIndexElem(index)}
                            {lineElem}
                        </div>
                    );
                }
            }

            class CollapseIcon extends React.Component {
                constructor() {
                    super();
                    this.toggleCollapse = this.toggleCollapse.bind(this);
                }

                toggleCollapse(e) {
                    this.props.step.isCollapsed = !this.props.step.isCollapsed;
                }

                render() {
                    let plusElem = <img
                        className="collapse plus"
                        onClick={this.toggleCollapse}
                        src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiA/PjxzdmcgaGVpZ2h0PSIxNzkyIiB2aWV3Qm94PSIwIDAgMTc5MiAxNzkyIiB3aWR0aD0iMTc5MiIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cGF0aCBkPSJNMTM0NCA4MDB2NjRxMCAxNC05IDIzdC0yMyA5aC0zNTJ2MzUycTAgMTQtOSAyM3QtMjMgOWgtNjRxLTE0IDAtMjMtOXQtOS0yM3YtMzUyaC0zNTJxLTE0IDAtMjMtOXQtOS0yM3YtNjRxMC0xNCA5LTIzdDIzLTloMzUydi0zNTJxMC0xNCA5LTIzdDIzLTloNjRxMTQgMCAyMyA5dDkgMjN2MzUyaDM1MnExNCAwIDIzIDl0OSAyM3ptMTI4IDQ0OHYtODMycTAtNjYtNDctMTEzdC0xMTMtNDdoLTgzMnEtNjYgMC0xMTMgNDd0LTQ3IDExM3Y4MzJxMCA2NiA0NyAxMTN0MTEzIDQ3aDgzMnE2NiAwIDExMy00N3Q0Ny0xMTN6bTEyOC04MzJ2ODMycTAgMTE5LTg0LjUgMjAzLjV0LTIwMy41IDg0LjVoLTgzMnEtMTE5IDAtMjAzLjUtODQuNXQtODQuNS0yMDMuNXYtODMycTAtMTE5IDg0LjUtMjAzLjV0MjAzLjUtODQuNWg4MzJxMTE5IDAgMjAzLjUgODQuNXQ4NC41IDIwMy41eiIvPjwvc3ZnPg=="
                    />;

                    let minusElem = <img
                        className="collapse minus"
                        onClick={this.toggleCollapse}
                        src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiA/PjxzdmcgZmlsbD0ibm9uZSIgaGVpZ2h0PSIyNCIgc3Ryb2tlPSIjMDAwIiBzdHJva2UtbGluZWNhcD0icm91bmQiIHN0cm9rZS1saW5lam9pbj0icm91bmQiIHN0cm9rZS13aWR0aD0iMiIgdmlld0JveD0iMCAwIDI0IDI0IiB3aWR0aD0iMjQiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHJlY3QgaGVpZ2h0PSIxOCIgcng9IjIiIHJ5PSIyIiB3aWR0aD0iMTgiIHg9IjMiIHk9IjMiLz48bGluZSB4MT0iOCIgeDI9IjE2IiB5MT0iMTIiIHkyPSIxMiIvPjwvc3ZnPg=="
                    />;

                    let nonCollapsibleElem = <img
                        className="collapse noncollapsible"
                        src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiA/PjxzdmcgZmlsbD0ibm9uZSIgaGVpZ2h0PSIyNCIgc3Ryb2tlPSIjMDAwIiBzdHJva2UtbGluZWNhcD0icm91bmQiIHN0cm9rZS1saW5lam9pbj0icm91bmQiIHN0cm9rZS13aWR0aD0iMiIgdmlld0JveD0iMCAwIDI0IDI0IiB3aWR0aD0iMjQiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHJlY3QgaGVpZ2h0PSIxOCIgcng9IjIiIHJ5PSIyIiB3aWR0aD0iMTgiIHg9IjMiIHk9IjMiLz48L3N2Zz4="
                    />;

                    let placeholderElem = <span className="collapse-placeholder"/>;

                    if(this.props.step.hasChildren) {
                        if(this.props.step.isCollapsed === true) {
                            return plusElem;
                        }
                        else {
                            return minusElem;
                        }
                    }
                    else {
                        if(this.props.hasLevels) {
                            return placeholderElem;
                        }
                        else {
                            return "";
                        }
                    }
                }
            }

            class PreviewPane extends React.Component {
                constructor() {
                    super();
                }

                componentDidUpdate() {
                    attachPreviewPaneTooltips();
                }

                render() {
                    if(this.props.previewedItem) {
                        return (
                            <Preview previewedItem={this.props.previewedItem} setPreview={this.props.setPreview} live={this.props.live}/>
                        );
                    }
                    else {
                        return (
                            <NoPreview />
                        );
                    }
                }
            }

            function NoPreview(props) {
                return (
                    <div className="pane preview-pane hidden">
                    </div>
                );
            }

            function Preview(props) {
                let previewedItem = props.previewedItem.props.step || props.previewedItem.props.branch;
                let isBranch = previewedItem.hasOwnProperty("steps");

                let headerClassName = "header preview-name ";
                let previewStateClassName = "preview-state ";
                let previewStateText = "";
                let pill = "";
                if(previewedItem.isRunning) {
                    headerClassName += "running-item-no-anim";
                    previewStateClassName += "running-item";
                    previewStateText = "Currently running";
                }
                else if(previewedItem.isPassed) {
                    const className = "passed-item";
                    headerClassName += className;
                    previewStateClassName += className;

                    previewStateText = "Passed";
                }
                else if(previewedItem.isFailed) {
                    const className = "failed-item";
                    headerClassName += className;
                    previewStateClassName += className;

                    previewStateText = "Failed";

                    if(previewedItem.error && previewedItem.error.continue) {
                        previewStateText += ", but continued branch";
                    }
                }
                else if(previewedItem.isSkipped) {
                    const className = "skipped-item";
                    headerClassName += className;
                    previewStateClassName += className;
                    previewStateText = "Skipped";
                }
                else { // Not run yet
                    const className = "notrunyet-item";
                    headerClassName += className;
                    previewStateClassName += className;
                    previewStateText = "Not run yet";
                }

                let elapsedText = "";
                let elapsed = previewedItem.elapsed;
                if(typeof elapsed != "undefined" && elapsed != -1) {
                    elapsedText = `(${formatElapsed(elapsed)})`;
                }

                let className = `pane preview-pane ${isBranch ? "branch-preview" : "step-preview"}`;

                let previewedItemText = "";
                if(isBranch) {
                    previewedItemText = `Branch ${props.previewedItem.props.branch.hash}`;
                }
                else {
                    previewedItemText = stepText(previewedItem);
                }

                let postPreviewedItemText = "";
                if(isBranch) {
                    postPreviewedItemText = `[${previewedItem.steps[previewedItem.steps.length - 1].filename}:${previewedItem.steps[previewedItem.steps.length - 1].lineNumber}] ${elapsedText}`;
                }
                else {
                    postPreviewedItemText = `[${previewedItem.filename}:${previewedItem.lineNumber}] ${elapsedText}`;
                }

                return (
                    <div className={className}>
                        <div className="close" onClick={() => {props.setPreview(null)}}>&#xd7;</div>

                        <div className={headerClassName}>
                            {previewedItemText}
                        </div>

                        <div className={previewStateClassName}>
                            {previewStateText}
                            {pill}
                            <span className="location">{postPreviewedItemText}</span>
                        </div>

                        <div className="msg">
                            {
                                isBranch ?
                                "" :
                                <span>Branch {props.previewedItem.props.branch.hash} <span className="commandline-hint">Hover here for keystrokes</span></span>
                            }
                        </div>

                        <div className="preview-divider">
                            {
                                props.live ?
                                <div className="msg updates-paused">
                                    Live updates paused. Close this preview to resume live updates.
                                </div> :
                                ''
                            }
                        </div>

                        <PreviewError previewedItem={previewedItem}/>
                        {isBranch ? "" : <PreviewDetails previewedItem={previewedItem}/>}
                        <PreviewLogs previewedItem={previewedItem}/>
                    </div>
                );
            }

            function PreviewError(props) {
                if(props.previewedItem.error) {
                    return (
                        <div className="preview-section preview-error">
                            <div className="header">Error</div>
                            <div className="stacktrace">
                                {formatStackTrace(props.previewedItem.error)}
                            </div>
                        </div>
                    );
                }
                else {
                    return "";
                }
            }

            class PreviewDetails extends React.Component {
                constructor() {
                    super();
                }

                componentDidMount() {
                    this.updateScripts();
                }

                componentDidUpdate() {
                    this.updateScripts();
                }

                updateScripts() {
                    // Since <script> scripts aren't executed when they're injected into the DOM by React, we have to do a workaround
                    // Execute <script> tags with class details-init-js
                    let oldScriptElem = document.querySelector(".details-init-js");
                    if(oldScriptElem) {
                        let oldScriptText = oldScriptElem.innerText;
                        oldScriptElem.parentNode.removeChild(oldScriptElem);

                        let newScriptElem = document.createElement("script");
                        let newScriptTextNode = document.createTextNode(oldScriptText);
                        newScriptElem.appendChild(newScriptTextNode);
                        document.querySelector(".step-report").appendChild(newScriptElem);
                    }
                }

                render() {
                    return (
                        <div className="preview-section preview-details">
                            <div className="header">Details</div>
                            {
                                this.props.previewedItem.htmlReport ?
                                <div className="step-report" dangerouslySetInnerHTML={ {__html: this.props.previewedItem.htmlReport} }>
                                </div> :
                                <div className="none-indicator">
                                    None
                                </div>
                            }
                        </div>
                    );
                }
            }

            function PreviewLogs(props) {
                let logs = props.previewedItem.log;
                if(logs) {
                    logs = logs.map((logItem, index) => <div className="log-line" key={index}>{logItem.text}</div>);
                }

                return (
                    <div className="preview-section preview-logs">
                        <div className="header">Logs</div>
                        {
                            logs ?
                            <div className="logs">
                                {logs}
                            </div> :
                            <div className="none-indicator">
                                None
                            </div>
                        }
                    </div>
                );
            }

            ReactDOM.render(
                <App />,
                document.getElementById("root")
            );

            /**
             * Converts a number of ms to Xh Xm Xs Xms format
             */
            function formatElapsed(ms) {
                let hours = Math.floor(ms/3600000);
                ms %= 3600000;
                let mins = Math.floor(ms/60000);
                ms %= 60000;
                let secs = Math.floor(ms/1000);
                ms %= 1000;

                return (hours > 0 ? hours + "h " : "") +
                    (hours > 0 || mins > 0 ? mins + "m " : "") +
                    (hours > 0 || mins > 0 || secs > 0 ? secs + "s" : "") +
                    (hours == 0 && mins == 0 && secs == 0 ? ms + "ms" : "");
            }

            /**
             * Injects [filename:lineNumber] into the given Error's stack trace, and returns it
             */
            function formatStackTrace(error) {
                return error.stackTrace.replace(/\n/, `   [${error.filename}:${error.lineNumber}]\n`);
            }

            /**
             * Injects [filename:lineNumber] into the given Error's message, and returns it
             */
            function formatErrorMsg(error) {
                return error.msg + `   [${error.filename}:${error.lineNumber}]`;
            }

            /**
             * @return {Boolean} True if elem is in view, false otherwise
             */
            function isScrolledIntoView(elem) {
                var rect = elem.getBoundingClientRect();
                return (rect.top >= 0) && (rect.bottom <= window.innerHeight);
            }

            /**
             * Scrolls elem into view if it's not in view
             */
            function scrollIntoView(elem) {
                if(!isScrolledIntoView(elem)) {
                    elem.scrollIntoView({
                        block: 'nearest'
                    });
                }
            }

            attachTreePaneTooltips();
        </script>
    </body>
</html>
