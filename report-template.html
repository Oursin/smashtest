<html>
    <head>
        <meta name="tree" content="{{{tree}}}"/>
        <meta name="runner" content="{{{runner}}}"/>
        <meta name="reportTime" content="{{{reportTime}}}"/>
        <meta name="domain" content="{{{domain}}}"/>

        <title>SmashTEST Report</title>

        <script src="https://unpkg.com/popper.js@1"></script>
        <script src="https://unpkg.com/tippy.js@4"></script>

        <script src="https://unpkg.com/react@16/umd/react.development.js" crossorigin></script>
        <script src="https://unpkg.com/react-dom@16/umd/react-dom.development.js" crossorigin></script>
        <script src="https://unpkg.com/babel-standalone@6/babel.min.js"></script>

        <style>
            body {
                background-color: rgb(30,30,30);
                color: white;
                font-family: Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
                margin: 0;
                padding: 0;
                overflow-y: hidden;
            }

            .header {
                font-size: 16px;
                margin: 0 0 20px 6px;
            }

            .tree-errors .header {
                margin-bottom: 0;
            }

            .pane {
                position: absolute;
                top: 0;
                bottom: 0;
                width: calc(50% - 15px);
                height: 100%;
                vertical-align: top;
                border: 0;
                margin: 0;
                overflow-y: auto;
                overflow-x: hidden;
            }

            .tree-pane {
                left: 0;
                padding: 10px 0 10px 8px;
            }

            .preview-pane {
                right: 0;
                padding: 10px 14px;
                background-color: rgb(45,45,45);
            }

            .tree-header {
                margin: 0 0 20px 0;
            }

            .tree-header-container {
                margin: 0 0 0 10px;
                font-size: 13px;
            }

            .tree-header-container .msg {
                font-size: 13px;
            }

            .runner-status-msg {
                color: #ffb347;
            }

            .debug-mode {
                margin-left: 30px;
            }

            .branch-list {
                margin: 0 0 30px 0;
            }

            .branch {
                margin-bottom: 30px;
                margin-left: 8px;
                position: relative;
            }

            .branch.active {
                background-color: rgb(45,45,45);
            }

            .branch.hover {
                background-color: rgb(45,45,45);
                /*background-color: rgb(70,70,70);*/
            }

            .branch-indicator {
                display: inline-block;
                position: absolute;
                top: 0;
                left: 0;
                width: 10px;
                height: 100%;
                min-width: 10px;
                border: 0;
                margin: 0;
                padding: 0;
                border-radius: 3px;
                z-index: 3;
            }

            .branch-indicator:hover {
                cursor: pointer;
            }

            .branch-indicator.notrunyet {
                background-color: gray;
            }

            .branch-indicator.running {
                background-color: orange;
                animation: blinker 2s linear infinite;
            }

            @keyframes blinker {
                50% {
                    opacity: 0.3;
                }
            }

            .branch-indicator.passed {
                background-color: green;
            }

            .branch-indicator.failed {
                background-color: red;
            }

            .branch-indicator.skipped {
                background-color: rgb(0,200,200);
            }

            .branch-contents {
                display: inline-block;
                width: 100%;
                border: 0;
                margin: 0;
                padding-left: 10px;
                padding-right: 0;
            }

            .line {
                font-size: 14px;
                position: relative;
                white-space: nowrap;
                cursor: pointer;
                overflow-x: auto;
                padding-right: 20px;
                /*padding: 1px 20px 1px 0;*/
            }

            .line::-webkit-scrollbar {
                display: none;
            }

            .line.active {
                background-color: rgb(45,45,45);
            }

            .line:hover {
                background-color: rgb(45,45,45);
                /*background-color: rgb(70,70,70);*/
            }

            .line .line-container {
                display: inline-block;
            }

            .line .content {
                display: inline-block;
            }

            .line .location {
                display: inline-block;
                vertical-align: top;
                color: transparent;
                padding: 0 30px;
                font-size: 13px;
            }

            .line:hover .location {
                color: rgb(90,90,90);
            }

            .pill {
                position: relative;
                top: -2px;
                color: white;
                padding: 1px 3px;
                border-radius: 5px;
                font-size: 11px;
                margin: 0 10px;
            }

            .pill.expected {
                background-color: green;
            }

            .pill.unexpected {
                background-color: red;
            }

            .pill.skipped {
                background-color: rgb(0,200,200);
            }

            .pill.running {
                background-color: orange;
            }

            .tooltip-text {
                font-size: 12px;
            }

            .tooltip-text.keystrokes {
                text-align: left;
                padding: 5px;
                white-space: pre;
                line-height: 1.7;
            }

            .tree-header-item {
                margin-bottom: 5px;
            }

            .progress-bar {
                height: 20px;
                margin: -6px 10px 15px 0;
                padding-right: 20px;
            }

            .progress-bar .filled-bar {
                background-color: rgb(245,155,0);
                color: white;
                text-align: center;
                height: 100%;
                border-radius: 4px;
                overflow-x: hidden;
            }

            .progress-bar .filled-bar.paused {
                background-color: rgb(70,70,70);
            }

            .progress-bar .filled-bar-text {
                position: relative;
                top: 2px;
                padding: 0 5px;
            }

            .msg {
                color: rgb(100,100,100);
                font-size: 12px;
                font-weight: normal;
            }

            .notrunyet-item {
                color: gray;
            }

            .running-item {
                color: orange;
                animation: blinker 2s linear infinite;
            }

            .running-item-no-anim,
            .orange-item {
                color: orange;
            }

            .passed-item {
                color: rgb(0,200,0);
            }

            .failed-item {
                color: red;
            }

            .skipped-item {
                color: rgb(0,200,200);
            }

            .counts {
                line-height: 16px;
            }

            .line-index {
                color: rgb(100,100,100);
                font-size: 11px;
                display: inline-block;
                vertical-align: top;
                position: relative;
                top: 2px;
                margin: 0 8px;
            }

            .vertical-line-container {
                border-left: 1px dashed rgb(100,100,100);
                margin-left: 4px;
                padding-left: 8px;
                display: inline-block;
            }

            .line > .vertical-line-container {
                position: relative;
                top: 1px;
                margin-bottom: 1px;
            }

            .stacktrace {
                padding: 10px 0 25px 30px;
                color: rgb(220,220,220);
                font-size: 12px;
                white-space: pre;
            }

            .tree-errors .stacktrace {
                overflow-x: auto;
                margin-right: 10px;
            }

            .branch-error .stacktrace {
                overflow-x: auto;
                margin-right: 20px;
            }

            .preview-pane .stacktrace {
                padding: 0 30px 15px;
                overflow-x: auto;
            }

            .logs {
                padding: 5px 0 20px 20px;
                color: rgb(110,110,110);
                font-size: 12px;
            }

            .log-line {
                margin-bottom: 7px;
            }

            .thumbs-up {
                cursor: default;
            }

            .preview-pane .preview-name {
                margin-bottom: 10px;
            }

            .preview-pane .preview-state .location {
                color: rgb(110,110,110);
                font-size: 12px;
                margin-left: 20px;
            }

            .preview-pane .preview-name .elapsed {
                color: rgb(110,110,110);
                font-size: 12px;
            }

            .preview-pane .preview-state {
                margin-left: 20px;
                font-size: 13px;
            }

            .preview-pane .msg {
                color: rgb(110,110,110);
                margin-top: 10px;
                margin-left: 20px;
                font-size: 13px;
            }

            .preview-pane .msg.updates-paused {
                margin-bottom: 30px;
            }

            .preview-pane .preview-state .pill {
                position: relative;
                top: -1px;
                cursor: pointer;
            }

            .preview-pane .commandline-hint {
                margin-left: 20px;
                font-size: 12px;
                cursor: pointer;
            }

            .step-report {
                margin: 20px;
            }

            .preview-pane-msg {
                color: rgb(90,90,90);
                font-size: 18px;
                padding-top: 70px;
                text-align: center;
            }

            .preview-section {
                margin: 0 0 30px 0;
            }

            .none-indicator {
                color: rgb(110,110,110);
                font-size: 13px;
                margin-left: 20px;
            }

            #notification {
                visibility: hidden;
                position: fixed;
                text-align: center;
                top: 30px;
                left: 0;
                right: 0;
                z-index: 4;
            }

            #notification .notification-text {
                min-width: 250px;
                background-color: #333;
                color: #fff;
                border-radius: 2px;
                padding: 16px;
                font-size: 17px;
                border-radius: 5px;
            }

            #notification .notification-text .copied-text {
                color: rgb(180,180,180);
            }

            #notification.show {
                visibility: visible;
                -webkit-animation: fadein 0.5s, fadeout 0.5s 2.5s;
                animation: fadein 0.5s, fadeout 0.5s 2.5s;
            }

            @-webkit-keyframes fadein {
                from {top: 0; opacity: 0;}
                to {top: 30px; opacity: 1;}
            }

            @keyframes fadein {
                from {top: 0; opacity: 0;}
                to {top: 30px; opacity: 1;}
            }

            @-webkit-keyframes fadeout {
                from {top: 30px; opacity: 1;}
                to {top: 0; opacity: 0;}
            }

            @keyframes fadeout {
                from {top: 30px; opacity: 1;}
                to {top: 0; opacity: 0;}
            }
        </style>
    </head>
    <body>
        <div id="root"></div>

        <script type="text/babel">
            // Tooltips

            let tippyOptions = {
                placement: "right",
                followCursor: true,
                delay: 0,
                animation: "fade",
                arrow: true,
                arrowType: "sharp"
            };

            function wrapTippyContent(content) {
                return `<span class='tooltip-text'>${content}</span>`;
            }

            function wrapTippyContentForKeystrokes(content) {
                return `<div class='tooltip-text keystrokes'>${content.trim()}</div>`;
            }

            function attachPreviewPaneTooltips() {
                tippyOptions.content = wrapTippyContent("This step passed, but was<br>expected to fail (#)");
                tippy(".preview-pane .pill.unexpected", tippyOptions);

                tippyOptions.content = wrapTippyContent("This step failed,<br>as was expected (#)");
                tippy(".preview-pane .pill.expected", tippyOptions);

                tippyOptions.content = wrapTippyContentForKeystrokes(`
left  = previous step
right = next step
up    = toggle before/after
h     = copy hash
c     = copy debug command 'smashtest filename -d=hash'
                `);
                let tippyOptionsKeystrokes = Object.assign({}, tippyOptions);
                Object.assign(tippyOptionsKeystrokes, { followCursor: false, placement: "bottom", maxWidth: 1000 } );
                tippy(".preview-pane .commandline-hint", tippyOptionsKeystrokes);
            }

            function attachTreePaneTooltips() {
                tippyOptions.content = wrapTippyContent("Currently running branch");
                tippy(".branch-indicator.running", tippyOptions);

                tippyOptions.content = wrapTippyContent("Branch passed");
                tippy(".branch-indicator.passed", tippyOptions);

                tippyOptions.content = wrapTippyContent("Branch failed");
                tippy(".branch-indicator.failed", tippyOptions);

                tippyOptions.content = wrapTippyContent("Branch skipped");
                tippy(".branch-indicator.skipped", tippyOptions);

                tippyOptions.content = wrapTippyContent("Branch not run yet");
                tippy(".branch-indicator.notrunyet", tippyOptions);

                tippyOptions.content = wrapTippyContent("This step passed, but was<br>expected to fail (#)");
                tippy(".pill.unexpected", tippyOptions);

                tippyOptions.content = wrapTippyContent("This step failed,<br>as was expected (#)");
                tippy(".pill.expected", tippyOptions);

                /*tippyOptions.content = wrapTippyContent("Congrats! All branches passed");
                tippy(".thumbs-up", tippyOptions);*/
            }

            // React Components

            class App extends React.Component {
                constructor() {
                    super();

                    // State
                    this.state = {
                        tree: null,
                        runner: null,
                        reportTime: null,
                        previewedItem: null,
                        port: null,
                        live: true
                    };
                    this.preState = null;
                    this.slowPoll = false;

                    // App's DOM element
                    this.me = null;

                    // Parse in tree
                    let treeContent = document.querySelector("meta[name=tree]").getAttribute("content");
                    let treeJSON = this.unescapeHtml(treeContent);
                    if(!treeJSON.startsWith("\{\{\{")) {
                        this.state.tree = JSON.parse(treeJSON);
                    }

                    // Parse in runner
                    let runnerContent = document.querySelector("meta[name=runner]").getAttribute("content");
                    let runnerJSON = this.unescapeHtml(runnerContent);
                    if(!runnerJSON.startsWith("\{\{\{")) {
                        this.state.runner = JSON.parse(runnerJSON);
                    }

                    // Parse in reportTime
                    this.state.reportTime = document.querySelector("meta[name=reportTime]").getAttribute("content");

                    // Parse in domain
                    this.state.domain = document.querySelector("meta[name=domain]").getAttribute("content");

                    // Bindings
                    this.setUpdateLoop = this.setUpdateLoop.bind(this);
                    this.updateData = this.updateData.bind(this);
                    this.updateState = this.updateState.bind(this);
                    this.setPreview = this.setPreview.bind(this);
                    this.handleKeyDown = this.handleKeyDown.bind(this);
                    this.handleKeyUp = this.handleKeyUp.bind(this);
                    this.isModifierActive = this.isModifierActive.bind(this);
                    this.showNotification = this.showNotification.bind(this);
                    this.copyToClipboard = this.copyToClipboard.bind(this);
                }

                componentDidMount() {
                    if(window.location.href.match(/(^https?\:\/\/(localhost|127\.0\.0\.1))|(report\.html$)/)) { // dated reports from reports/ do not update themselves
                        this.setUpdateLoop();
                    }
                    else {
                        this.setState({
                            live: false
                        });
                    }

                    this.me.focus(); // focus on myself, so I can start getting keyboard commands
                }

                setUpdateLoop() {
                    // Start update loop
                    const UPDATE_FREQUENCY = 500; // in ms
                    const UPDATE_FREQUENCY_SLOW = 5000; // in ms
                    setTimeout(() => {
                        this.updateData().finally(this.setUpdateLoop);
                    }, this.slowPoll ? UPDATE_FREQUENCY_SLOW : UPDATE_FREQUENCY);
                }

                updateData() {
                    let self = this;
                    return new Promise((resolve, reject) => {
                        if(this.state.domain) {
                            let xhr = new XMLHttpRequest();
                            xhr.addEventListener("load", () => {
                                let preState = null
                                try {
                                    preState = JSON.parse(xhr.response);
                                }
                                catch(e) {
                                    this.slowPoll = true;
                                    resolve(); // fail silently
                                    return;
                                }

                                if(!preState) {
                                    this.slowPoll = true;
                                    resolve(); // fail silently
                                    return;
                                }

                                this.slowPoll = false;
                                self.preState = preState;
                                self.updateState();
                                resolve();
                            });
                            xhr.addEventListener("error", () => {
                                this.slowPoll = true;
                                self.updateState();
                                resolve(); // fail silently
                            });

                            xhr.open("GET", `${this.state.domain}/state?file=${encodeURIComponent(window.location.href.replace(/file\:\/\//, ''))}`);
                            xhr.send();
                        }
                        else {
                            resolve();
                        }
                    });
                }

                updateState() {
                    if(!this.state.previewedItem && this.preState) {
                        this.setState({
                            tree: this.preState.tree,
                            runner: this.preState.runner,
                            reportTime: this.preState.reportTime
                        });
                    }
                }

                unescapeHtml(str) {
                    return str
                        .replace(/&#039;/g, "'")
                        .replace(/&quot;/g, "\"")
                        .replace(/&gt;/g, ">")
                        .replace(/&lt;/g, "<")
                        .replace(/&amp;/g, "&");
                }

                setPreview(previewedItem) {
                    this.setState(state => {
                        if(state.previewedItem === previewedItem) { // toggle off
                            return {
                                previewedItem: null
                            };
                        }
                        else { // toggle on
                            return {
                                previewedItem: previewedItem
                            };
                        }
                    });
                }

                handleKeyDown(event) {
                    if(this.isModifierActive(event)) {
                        return;
                    }

                    let charCode = event.keyCode || event.which;
                    let charStr = String.fromCharCode(charCode);

                    if(charCode == '37') { // left arrow
                        let [lines, activeIndex] = getActiveIndex();
                        let prevIndex = activeIndex - 1;
                        if(activeIndex != -1 && prevIndex >= 0) {
                            lines[prevIndex].click();
                        }
                    }
                    else if(charCode == '39') { // right arrow
                        let [lines, activeIndex] = getActiveIndex();
                        let nextIndex = activeIndex + 1;
                        if(activeIndex != -1 && nextIndex < lines.length) {
                            lines[nextIndex].click();
                        }
                    }
                    else if(charCode == '38') { // up arrow
                        if(window.onUpArrowDown) {
                            window.onUpArrowDown();
                        }
                    }
                    else if(charStr == 'H') {
                        if(this.state.previewedItem) {
                            let hash = this.state.previewedItem.props.branch.hash;
                            this.copyToClipboard(hash);
                            this.showNotification(`Copied <span class="copied-text">${hash}</span> to clipboard`);
                        }
                    }
                    else if(charStr == 'C') {
                        if(this.state.previewedItem) {
                            let hash = this.state.previewedItem.props.branch.hash;
                            //let filename = this.state.previewedItem.props.branch.steps[0].filename;
                            //let command = `smashtest ${filename} -d=${hash}`;
                            let command = `smashtest -d=${hash}`;
                            this.copyToClipboard(command);
                            this.showNotification(`Copied  <span class="copied-text">${command}</span> to clipboard`);
                        }
                    }

                    function getActiveIndex() {
                        let lines = document.querySelectorAll(".line");
                        for(let i = 0; i < lines.length; i++) {
                            let line = lines[i];
                            if(line.classList.contains("active")) {
                                return [lines, i];
                            }
                        }

                        return [lines, -1];
                    }
                }

                handleKeyUp(event) {
                    if(this.isModifierActive(event)) {
                        return;
                    }

                    let charCode = event.keyCode || event.which;

                    if(charCode == '38') { // up arrow
                        if(window.onUpArrowUp) {
                            window.onUpArrowUp();
                        }
                    }
                }

                isModifierActive(event) {
                    return event.getModifierState("Shift") ||
                        event.getModifierState("Alt") ||
                        event.getModifierState("Control") ||
                        event.getModifierState("Meta") ||
                        event.getModifierState("Fn") ||
                        event.getModifierState("OS");
                }

                showNotification(msg) {
                    const NOTIFICATION_TIMEOUT = 3000; // ms
                    let notification = document.getElementById("notification");
                    let notificationText = notification.querySelector(".notification-text");
                    notificationText.innerHTML = msg;
                    notification.classList.add("show");
                    this.me.focus();
                    setTimeout(() => notification.classList.remove("show"), NOTIFICATION_TIMEOUT);
                }

                copyToClipboard(text) {
                    if(document.queryCommandSupported && document.queryCommandSupported("copy")) {
                        let textarea = document.createElement("textarea");
                        textarea.textContent = text;
                        textarea.style.position = "fixed";
                        document.body.appendChild(textarea);
                        textarea.select();
                        try {
                            return document.execCommand("copy");
                        }
                        catch (e) {
                        }
                        finally {
                            document.body.removeChild(textarea);
                        }
                    }
                }

                render() {
                    return (
                        <div className="main" tabIndex="0" onKeyDown={this.handleKeyDown} onKeyUp={this.handleKeyUp} ref={elem => this.me = elem}>
                            <div id="notification"><span className="notification-text"></span></div>
                            <TreePane data={this.state} setPreview={this.setPreview}/>
                            <PreviewPane previewedItem={this.state.previewedItem} live={this.state.live}/>
                        </div>
                    );
                }
            }

            function TreePane(props) {
                if(!props.data.tree) {
                    return "";
                }

                return (
                    <div className="pane tree-pane">
                        <TreeHeader data={props.data}/>
                        <TreeErrors data={props.data}/>
                        <BranchListing branches={props.data.tree.branches} setPreview={props.setPreview} previewedItem={props.data.previewedItem}/>
                    </div>
                );
            }

            function TreeHeader(props) {
                let elapsedText = "";
                let elapsed = props.data.tree.elapsed;
                if(typeof elapsed != undefined && elapsed != -1) {
                    elapsedText = `(${formatElapsed(elapsed)})`;
                }

                let anyFailed = false;
                for(let i = 0; i < props.data.tree.branches.length; i++) {
                    let branch = props.data.tree.branches[i];
                    if(branch.isFailed) {
                        anyFailed = true;
                        break;
                    }
                }

                let runnerStatusElem = null;
                if(props.data.runner.isStopped) {
                    runnerStatusElem = <span>Run stopped {elapsedText}</span>
                }
                else if(props.data.runner.isComplete) {
                    runnerStatusElem = <span>Run completed {elapsedText}</span>;
                }
                else if(props.data.runner.isPaused) {
                    runnerStatusElem = <span>Run paused</span>;
                }
                else { // currently running
                    runnerStatusElem = <span className="running-item">Currently running</span>;
                }

                let totalRunning = 0;
                props.data.tree.branches.forEach(branch => branch.isRunning && totalRunning++);

                let totalNotRunYet = props.data.tree.totalToRun - props.data.tree.complete - totalRunning;

                return (
                    <div className="tree-header">
                        <div className="header">{/*props.data.live ? "Live " : ""*/}SmashTEST Report</div>
                        <div className="tree-header-container">
                            {
                                !props.data.runner.isComplete && !props.data.runner.isStopped ?
                                <ProgressBar decimal={props.data.tree.totalStepsComplete / props.data.tree.totalSteps} paused={/*props.data.runner.isPaused ||*/ props.data.previewedItem}/> :
                                ""
                            }
                            <div className="runner-status-msg tree-header-item">
                                {runnerStatusElem}
                                <span className="debug-mode">
                                    {props.data.tree.isDebug ? "In DEBUG mode (~)" : ""}
                                </span>
                            </div>
                            <div className="counts tree-header-item">
                                {
                                    totalRunning > 0 ?
                                    <span><span className="running-count running-item"> {totalRunning} running</span> | </span> :
                                    ""
                                }
                                {
                                    props.data.tree.passed > 0 ?
                                    <span><span className="passed-count passed-item"> {props.data.tree.totalPassedInReport} passed</span> | </span> :
                                    ""
                                }
                                {
                                    props.data.tree.failed > 0 ?
                                    <span><span className="failed-count failed-item"> {props.data.tree.failed} failed</span> | </span> :
                                    ""
                                }
                                {
                                    props.data.tree.skipped > 0 ?
                                    <span><span className="skipped-count skipped-item"> {props.data.tree.skipped} skipped</span> | </span> :
                                    ""
                                }
                                {
                                    totalNotRunYet > 0 ?
                                    <span><span className="notrunyet-count notrunyet-item"> {totalNotRunYet} not run yet</span> | </span> :
                                    ""
                                }
                                <span className="total-count notrunyet-item"> {props.data.tree.totalInReport} total branches</span>
                            </div>

                            {
                                !props.data.live ?
                                <div className="msg">
                                    This report is a snapshot. It is not live.
                                </div> :
                                ""
                            }
                        </div>
                    </div>
                );
            }

            class ProgressBar extends React.Component {
                constructor() {
                    super();
                    this.state = {
                        showPercentage: true
                    };
                }

                componentDidUpdate() {
                    if(this.filledBarText.scrollWidth > this.filledBar.offsetWidth) { // text doesn't have room
                        this.setState({
                            showPercentage: false
                        });
                    }
                }

                render() {
                    let percentageText = (Math.floor(this.props.decimal * 100)) + "%";
                    let filledBarClass = `filled-bar ${this.props.paused ? "paused" : ""}`;
                    return (
                        <div className="progress-bar tree-header-item">
                            <div className={filledBarClass} style={ {width: percentageText} } ref={(elem) => {this.filledBar = elem} }>
                                <div className="filled-bar-text" ref={(elem) => {this.filledBarText = elem}}>
                                    {this.state.showPercentage ? percentageText : ""}
                                </div>
                            </div>
                        </div>
                    );
                }
            }

            function TreeErrors(props) {
                let errors =
                    props.data.tree.beforeEverything
                    .concat(props.data.tree.afterEverything)
                    .filter(hook => {
                        return hook.error;
                    })
                    .map((hook, index) => {
                        return (
                            <div className="stacktrace" key={index}>
                                {formatStackTrace(hook.error)}
                            </div>
                        );
                    });

                if(errors.length > 0) {
                    return (
                        <div className="tree-errors">
                            <div className="header failed-item">Hook errors</div>
                            {errors}
                        </div>
                    );
                }
                else {
                    return "";
                }
            }

            function BranchListing(props) {
                let branchesRunning = props.branches
                    .filter(branch => branch.isRunning)
                    .map((branch, index) => <Branch key={index} branch={branch} setPreview={props.setPreview} previewedItem={props.previewedItem}/>);
                let branchesFailed = props.branches
                    .filter(branch => branch.isFailed)
                    .map((branch, index) => <Branch key={index} branch={branch} setPreview={props.setPreview} previewedItem={props.previewedItem}/>);
                let branchesPassed = props.branches
                    .filter(branch => branch.isPassed)
                    .map((branch, index) => <Branch key={index} branch={branch} setPreview={props.setPreview} previewedItem={props.previewedItem}/>);
                let branchesSkipped = props.branches
                    .filter(branch => branch.isSkipped)
                    .map((branch, index) => <Branch key={index} branch={branch} setPreview={props.setPreview} previewedItem={props.previewedItem}/>);
                let branchesNotRunYet = props.branches
                    .filter(branch => !branch.isRunning && !branch.isFailed && !branch.isPassed && !branch.isSkipped)
                    .map((branch, index) => <Branch key={index} branch={branch} setPreview={props.setPreview} previewedItem={props.previewedItem}/>);

                return (
                    <div className="branch-listing">
                        {
                            branchesRunning.length > 0 ? (
                                <div className="branch-list">
                                    <div className="header">Branches currently running</div>
                                    {branchesRunning}
                                </div>
                            ) : ""
                        }

                        {
                            branchesFailed.length > 0 ? (
                                <div className="branch-list">
                                    <div className="header">Failed branches</div>
                                    {branchesFailed}
                                </div>
                            ) : ""
                        }

                        {
                            branchesPassed.length > 0 ? (
                                <div className="branch-list">
                                    <div className="header">Passed branches</div>
                                    {branchesPassed}
                                </div>
                            ) : ""
                        }

                        {
                            branchesSkipped.length > 0 ? (
                                <div className="branch-list">
                                    <div className="header">Skipped branches</div>
                                    {branchesSkipped}
                                </div>
                            ) : ""
                        }

                        {
                            branchesNotRunYet.length > 0 ? (
                                <div className="branch-list">
                                    <div className="header">Branches not run yet</div>
                                    {branchesNotRunYet}
                                </div>
                            ) : ""
                        }
                    </div>
                );
            }

            class Branch extends React.Component {
                constructor() {
                    super();
                    this.state = {
                        hovered: false
                    };

                    this.hoverStateOn = this.hoverStateOn.bind(this);
                    this.hoverStateOff = this.hoverStateOff.bind(this);
                    this.toggleActiveState = this.toggleActiveState.bind(this);
                }

                hoverStateOn() {
                    this.setState({
                        hovered: true
                    });
                }

                hoverStateOff() {
                    this.setState({
                        hovered: false
                    });
                }

                toggleActiveState() {
                    this.props.setPreview(this);
                }

                render() {
                    let indicatorClassName = "branch-indicator ";

                    if(this.props.branch.isRunning) {
                        indicatorClassName += "running";
                    }
                    else if(this.props.branch.isFailed) {
                        indicatorClassName += "failed";
                    }
                    else if(this.props.branch.isPassed) {
                        indicatorClassName += "passed";
                    }
                    else if(this.props.branch.isSkipped) {
                        indicatorClassName += "skipped";
                    }
                    else {
                        indicatorClassName += "notrunyet";
                    }

                    let error = "";
                    if(this.props.branch.error) {
                        error = (
                            <div className="stacktrace">
                                {formatStackTrace(this.props.branch.error)}
                            </div>
                        );
                    }

                    let lines = this.props.branch.steps.filter(step => !step.isHidden).map((step, index) =>
                            <Line
                                step={step}
                                branch={this.props.branch}
                                index={index+1}
                                key={index}
                                lastIndex={this.props.branch.steps.length - 1}
                                setPreview={this.props.setPreview}
                                previewedItem={this.props.previewedItem}
                            />);

                    let branchClassName = "branch ";
                    if(this.state.hovered) {
                        branchClassName += "hover ";
                    }
                    if(this.props.previewedItem === this) {
                        branchClassName += "active ";
                    }

                    return (
                        <div className={branchClassName}>
                            <div
                                className={indicatorClassName}
                                onMouseOver={this.hoverStateOn}
                                onMouseOut={this.hoverStateOff}
                                onClick={this.toggleActiveState}
                            >
                            </div>
                            <div className="branch-contents">
                                <div className="branch-error">
                                    {error}
                                </div>
                                <div className="steps">
                                    {lines}
                                </div>
                            </div>
                        </div>
                    );
                }
            }

            class Line extends React.Component {
                constructor() {
                    super();
                    this.toggleActiveState = this.toggleActiveState.bind(this);
                }

                surroundByVerticalLineContainers(elem, n) {
                    for(let i = 0; i < n; i++) {
                        elem = this.surroundByVerticalLineContainer(elem);
                    }

                    return elem;
                }

                surroundByVerticalLineContainer(elem) {
                    return (
                        <span className="vertical-line-container">
                            {elem}
                        </span>
                    );
                }

                toggleActiveState() {
                    this.props.setPreview(this);
                }

                render() {
                    // Add an &nbsp; in front of the line number depending on the amount of digits in the last step of this branch (so they're all the same length)
                    let index = this.props.index;
                    let indexDigits = index.toString().length;
                    let maxDigits = this.props.lastIndex.toString().length;

                    function getIndexElem(index) {
                        return <span className="line-index">{indexElemSpaces(indexDigits)}{index}</span>;
                    }

                    function indexElemSpaces(i) {
                        if(i < maxDigits) {
                            return <span>&nbsp;{indexElemSpaces(i+1)}</span>;
                        }
                    }

                    let contentClassName = "content ";
                    let pill = "";
                    if(this.props.step.isRunning) {
                        contentClassName += "running running-item";
                        pill = <span className="pill running">RUNNING</span>;
                    }
                    else if(this.props.step.isPassed) {
                        if(this.props.step.asExpected) {
                            contentClassName += "passed-expected passed-item";
                        }
                        else {
                            contentClassName += "passed-unexpected passed-item";
                            pill = <span className="pill unexpected">UNEXPECTED</span>;
                        }
                    }
                    else if(this.props.step.isFailed) {
                        if(this.props.step.asExpected) {
                            contentClassName += "failed-expected failed-item";
                            pill = <span className="pill expected">EXPECTED</span>;
                        }
                        else {
                            contentClassName += "failed-unexpected failed-item";
                        }
                    }
                    else if(this.props.step.isSkipped) {
                        contentClassName += "skipped skipped-item";
                        pill = <span className="pill skipped">SKIPPED</span>;
                    }
                    else { // not run yet
                        contentClassName += "notrunyet notrunyet-item";
                    }

                    let error = "";
                    if(this.props.step.error) {
                        error = (
                            <div className="stacktrace">
                                {formatStackTrace(this.props.step.error)}
                            </div>
                        );
                    }

                    let lineElem = (
                        <span className="line-container">
                            <span className={contentClassName}>
                                {this.props.step.line.trim()}
                                {pill}
                            </span>
                            <span className="location">[{this.props.step.filename}:{this.props.step.lineNumber}]</span>
                            {error}
                        </span>
                    );
                    lineElem = this.surroundByVerticalLineContainers(lineElem, this.props.step.level);

                    let lineClassName = "line ";
                    if(this.props.previewedItem === this) {
                        lineClassName += "active ";
                    }

                    return (
                        <div className={lineClassName} onClick={this.toggleActiveState}>
                            {getIndexElem(index)}
                            {lineElem}
                        </div>
                    );
                }
            }

            class PreviewPane extends React.Component {
                constructor() {
                    super();
                }

                componentDidUpdate() {
                    attachPreviewPaneTooltips();
                }

                render() {
                    if(this.props.previewedItem) {
                        return (
                            <Preview previewedItem={this.props.previewedItem} live={this.props.live}/>
                        );
                    }
                    else {
                        return (
                            <NoPreview />
                        );
                    }
                }
            }

            function NoPreview(props) {
                return (
                    <div className="pane preview-pane">
                        <div className="preview-pane-msg">
                            &lt; Select a step to preview
                        </div>
                    </div>
                );
            }

            function Preview(props) {
                let previewedItem = props.previewedItem.props.step || props.previewedItem.props.branch;
                let isBranch = previewedItem.hasOwnProperty("steps");

                let headerClassName = "header preview-name ";
                let previewStateClassName = "preview-state ";
                let previewStateText = "";
                let pill = "";
                if(previewedItem.isRunning) {
                    headerClassName += "running-item-no-anim";
                    previewStateClassName += "running-item";
                    previewStateText = "Currently running";
                }
                else if(previewedItem.isPassed) {
                    const className = "passed-item";
                    headerClassName += className;
                    previewStateClassName += className;

                    previewStateText = "Passed";

                    if(previewedItem.asExpected === false) {
                        pill = <span className="pill unexpected">UNEXPECTED</span>;
                    }
                }
                else if(previewedItem.isFailed) {
                    const className = "failed-item";
                    headerClassName += className;
                    previewStateClassName += className;

                    previewStateText = "Failed";

                    if(previewedItem.error && previewedItem.error.continue) {
                        previewStateText += ", but continued branch";
                    }

                    if(previewedItem.asExpected === true) {
                        pill = <span className="pill expected">EXPECTED</span>;
                    }
                }
                else if(previewedItem.isSkipped) {
                    const className = "skipped-item";
                    headerClassName += className;
                    previewStateClassName += className;
                    previewStateText = "Skipped";
                }
                else { // Not run yet
                    const className = "notrunyet-item";
                    headerClassName += className;
                    previewStateClassName += className;
                    previewStateText = "Not run yet";
                }

                let elapsedText = "";
                let elapsed = previewedItem.elapsed;
                if(typeof elapsed != "undefined" && elapsed != -1) {
                    elapsedText = `(${formatElapsed(elapsed)})`;
                }

                let className = `pane preview-pane ${isBranch ? "branch-preview" : "step-preview"}`;

                let previewedItemText = "";
                if(isBranch) {
                    previewedItemText = `Branch ${props.previewedItem.props.branch.hash}`;
                }
                else {
                    previewedItemText = previewedItem.line.trim();
                }

                let postPreviewedItemText = "";
                if(isBranch) {
                    postPreviewedItemText = `[${previewedItem.steps[previewedItem.steps.length - 1].filename}:${previewedItem.steps[previewedItem.steps.length - 1].lineNumber}] ${elapsedText}`;
                }
                else {
                    postPreviewedItemText = `[${previewedItem.filename}:${previewedItem.lineNumber}] ${elapsedText}`;
                }

                return (
                    <div className={className}>
                        <div className={headerClassName}>
                            {previewedItemText}
                        </div>

                        <div className={previewStateClassName}>
                            {previewStateText}
                            {pill}
                            <span className="location">{postPreviewedItemText}</span>
                        </div>

                        <div className="msg">
                            {
                                isBranch ?
                                "" :
                                <span>Branch {props.previewedItem.props.branch.hash} <span className="commandline-hint">Hover here for keystrokes</span></span>
                            }
                        </div>
                        <div className="msg updates-paused">
                            {
                                props.live ?
                                `Live updates are paused. Unselect this ${isBranch ? "branch" : "step"} to resume live updates.` :
                                ""
                            }
                        </div>

                        <PreviewError previewedItem={previewedItem}/>
                        {isBranch ? "" : <PreviewDetails previewedItem={previewedItem}/>}
                        <PreviewLogs previewedItem={previewedItem}/>
                    </div>
                );
            }

            function PreviewError(props) {
                if(props.previewedItem.error) {
                    return (
                        <div className="preview-section preview-error">
                            <div className="header">Error</div>
                            <div className="stacktrace">
                                {formatStackTrace(props.previewedItem.error)}
                            </div>
                        </div>
                    );
                }
                else {
                    return "";
                }
            }

            class PreviewDetails extends React.Component {
                constructor() {
                    super();
                }

                componentDidMount() {
                    this.updateScripts();
                }

                componentDidUpdate() {
                    this.updateScripts();
                }

                updateScripts() {
                    // Since <script> scripts aren't executed when they're injected into the DOM by React, we have to do a workaround
                    // Execute <script> tags with class details-init-js
                    let oldScriptElem = document.querySelector(".details-init-js");
                    if(oldScriptElem) {
                        let oldScriptText = oldScriptElem.innerText;
                        oldScriptElem.parentNode.removeChild(oldScriptElem);

                        let newScriptElem = document.createElement("script");
                        let newScriptTextNode = document.createTextNode(oldScriptText);
                        newScriptElem.appendChild(newScriptTextNode);
                        document.querySelector(".step-report").appendChild(newScriptElem);
                    }
                }

                render() {
                    return (
                        <div className="preview-section preview-details">
                            <div className="header">Details</div>
                            {
                                this.props.previewedItem.htmlReport ?
                                <div className="step-report" dangerouslySetInnerHTML={ {__html: this.props.previewedItem.htmlReport} }>
                                </div> :
                                <div className="none-indicator">
                                    None
                                </div>
                            }
                        </div>
                    );
                }
            }

            function PreviewLogs(props) {
                let logs = props.previewedItem.log;
                if(logs) {
                    logs = logs.map((logItem, index) => <div className="log-line" key={index}>{logItem.text}</div>);
                }

                return (
                    <div className="preview-section preview-logs">
                        <div className="header">Logs</div>
                        {
                            logs ?
                            <div className="logs">
                                {logs}
                            </div> :
                            <div className="none-indicator">
                                None
                            </div>
                        }
                    </div>
                );
            }

            ReactDOM.render(
                <App />,
                document.getElementById("root")
            );

            /**
             * Converts a number of ms to Xh Xm Xs Xms format
             */
            function formatElapsed(ms) {
                let hours = Math.floor(ms/3600000);
                ms %= 3600000;
                let mins = Math.floor(ms/60000);
                ms %= 60000;
                let secs = Math.floor(ms/1000);
                ms %= 1000;

                return (hours > 0 ? hours + "h " : "") +
                    (hours > 0 || mins > 0 ? mins + "m " : "") +
                    (hours > 0 || mins > 0 || secs > 0 ? secs + "s" : "") +
                    (hours == 0 && mins == 0 && secs == 0 ? ms + "ms" : "");
            }

            /**
             * Injects [filename:lineNumber] into the given Error's stack trace, and returns it
             */
            function formatStackTrace(error) {
                return error.stackTrace.replace(/\n/, `   [${error.filename}:${error.lineNumber}]\n`);
            }

            attachTreePaneTooltips();
        </script>
    </body>
</html>
