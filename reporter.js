const fs = require('fs');
const readFiles = require('read-files-promise');
const mustache = require('mustache');
const utils = require('./utils.js');
const chalk = require('chalk');

/**
 * Generates a report on the status of the tree and runner
 */
class Reporter {
    constructor(tree, runner) {
        this.tree = tree;               // the Tree object to report on
        this.runner = runner;           // the Runner object to report on

        this.reportTemplate = "";       // template for html reports
        this.reportTime = null;         // Date when the report was generated

        this.maxSize = 1073741824;      // Maximum permissible size of report, in bytes, no limit if 0 (1 GB default)
        this.size = 0;                  // Size of report, in bytes

        this.reportPath = process.cwd() + "/report.html"; // absolute path of report.html being generated by this reporter
        this.domain = null;             // http(s)://domain:port where api endpoints available

        this.timer = null;              // timer that goes off when it's time to write the report to disk
        this.stopped = false;           // true if this Reporter was already stopped
    }

    /**
     * Starts the reporter, which generates and writes to disk a new report once every REPORT_GENERATE_FREQUENCY ms
     */
    async start() {
        // No reports for debug runs
        if(this.tree.isDebug) {
            this.stopped = true;
            return;
        }

        // Load template
        let buffers = await readFiles(['report-template.html'] , {encoding: 'utf8'});
        if(!buffers || !buffers[0]) {
            utils.error("report-template.html not found in this directory");
        }
        this.reportTemplate = buffers[0];

        await this.write();
    }

    /**
     * Stops the timer set by start()
     */
    async stop() {
        if(!this.stopped) {
            this.stopped = true;
            if(this.timer) {
                clearTimeout(this.timer);
                this.timer = null;
            }
            await this.write(); // one final time, to encompass last-second changes
        }
    }

    /**
     * Writes the report to disk
     */
    async write() {
        let reportData = this.generateReport();
        this.size = reportData.length;

        if(this.maxSize > 0 && this.size > this.maxSize) {
            utils.error(`Maximum report size exceeded (report size = ${(this.size/1048576).toFixed(3)} MB, max size = ${this.maxSize/1048576} MB)`);
        }

        await new Promise((res, rej) => fs.writeFile(this.reportPath, reportData, err => err ? rej(err) : res()));

        if(!this.stopped) {
            let REPORT_GENERATE_FREQUENCY = this.size < 300000000 ? 60000 : 300000; // if file size < 300 MB, every min, otherwise every 5 mins
            this.timer = setTimeout(() => this.write(), REPORT_GENERATE_FREQUENCY);
        }
    }

    /**
     * @return {String} The HTML report generated from this.tree and this.runner
     */
    generateReport() {
        this.tree.updateCounts();
        this.reportTime = new Date();

        let view = {
            tree: utils.escapeHtml(this.tree.serialize()),
            runner: utils.escapeHtml(this.runner.serialize()),
            reportTime: JSON.stringify(this.reportTime),
            domain: this.domain || ""
        }

        return mustache.render(this.reportTemplate, view);
    }

    /**
     * Reads in the given report html file, extracts json, merges it with tree
     */
    async mergeInLastReport(filename) {
        let lastReportPath = process.cwd() + "/" + filename;
        console.log(`Including passed branches from: ${chalk.gray(lastReportPath)}`);
        console.log("");

        let fileBuffers = null;
        try {
            fileBuffers = await readFiles([ filename ], {encoding: 'utf8'});
        }
        catch(e) {
            utils.error(`The file '${filename}' could not be found`);
        }

        let buffer = fileBuffers[0];
        buffer = this.extractTreeJson(buffer);
        this.tree.markPassedFromPrevRun(buffer);
    }

    /**
     * Extracts the report json from the given html report
     * @param {String} reportData - The raw html report
     * @return {String} The json object extracted from reportData
     * @throws {Error} If there was a problem extracting, or if the JSON is invalid
     */
    extractTreeJson(reportData) {
        const errMsg = "Error parsing the report from last time. Please try another file or do not use -s or --skip-passed.";

        let matches = htmlReport.match(/<div id="tree">([^<]*)<\/div>/);
        if(matches) {
            let content = matches[1];
            content = utils.unescapeHtml(content);
            try {
                JSON.parse(content);
            }
            catch(e) {
                utils.error(errMsg);
            }

            return content;
        }
        else {
            utils.error(errMsg);
        }
    }
}
module.exports = Reporter;
