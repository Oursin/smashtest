// NOTE: This file was used to experiment with different types of testing styles (hence the inconsistency of style)

* init {
    chai.use(i('chai-as-promised'));

    g('setPageBody',
        async function(htmlStr) {
            await browser.executeScript(function(htmlStr) {
                document.body.innerHTML = htmlStr;
            }, htmlStr);
        }
    );

    g(`test page location`, `file:///${dir()}/generic-page.html`);
}

open chrome       #mac #windows
open firefox      #mac #windows
open safari       #mac ! $s
open ie           #windows $s
open edge         #windows $s

    init
        navigate to {test page location}

            - BrowserInstance tests

                - Script injection tests

                    execScript() {
                        let body = await executeScript(function(a, b) {
                            document.body.innerHTML = a + b;
                            return document.body.innerHTML;
                        }, 'foo', 'bar');

                        expect(body).to.equal('foobar');
                    }

                    executeAsyncScript() {
                        let body = await executeAsyncScript(function(a, b, done) {
                            document.body.innerHTML = a + b;
                            done(document.body.innerHTML);
                        }, 'foo', 'bar');

                        expect(body).to.equal('foobar');
                    }

                - Elements tests

                    - '$()' tests

                        Given only some elements on a page are clickable

                            function $() is called

                                with a text EF
                                with an ElementFinder object

                                    and tryClickable is set to

                                        true

                                            When the call is made
                                                Then first matching element that is clickable is returned

                                        false

                                            When the call is made
                                                Then first matching element is returned

                                with a WebElement

                                    When the call is made
                                        Then the same WebElement is returned

                        Given no elements on a page are clickable

                            and function $() is called

                                with a text EF
                                with an ElementFinder object

                                    and tryClickable is set to

                                        true
                                        false

                                            When the call is made
                                                Then first matching element is returned

                                with a WebElement

                                    When the call is made
                                        Then the same WebElement is returned


                        * only some elements on a page are clickable {
                            await setPageBody(`
                                <div id="one" class="big">foobar</div>
                                <a id="two" class="big">foobar</div>
                                <button id="three" class="big">foobar</div>
                            `);
                        }

                        * no elements on a page are clickable {
                            await setPageBody(`
                                <div id="one" class="big">foobar</div>
                                <div id="two" class="big">foobar</div>
                                <span id="three" class="big">foobar</div>
                            `);
                        }

                        * function $() is called

                            * with a text EF {
                                g('element passed in',
                                    `.big`
                                );
                            }

                            * with an ElementFinder object {
                                g('element passed in',
                                    new ElementFinder(`.big`)
                                );
                            }

                            * with a WebElement {
                                g('element passed in',
                                    await browser.driver.findElement(By.id('two'))
                                );
                            }

                                * When the call is made {
                                    g('result element',
                                        await $(g('element passed in'))
                                    );
                                }

                                    * Then the same WebElement is returned {
                                        expect(await g('result element').getAttribute('id')).to.equal('two');
                                    }

                        * tryClickable is set to

                            * true

                                * When the call is made {
                                    g('result element',
                                        await $(g('element passed in'), true)
                                    );
                                }

                            * false

                                * When the call is made {
                                    g('result element',
                                        await $(g('element passed in'), false)
                                    );
                                }

                        * Then first matching element that is clickable is returned {
                            expect(await g('result element').getAttribute('id')).to.equal('two');
                        }

                        * Then first matching element is returned {
                            expect(await g('result element').getAttribute('id')).to.equal('one');
                        }

                    - '$$()' tests

                        Given a page with multiple elements

                            and function $$() is called

                                with a text EF
                                with an ElementFinder object

                                    and the EF has a counter
                                        When the call is made
                                            Then all matching elements are returned

                                    and the EF is missing a counter
                                        When the call is made
                                            Then all matching elements are returned

                                with a WebElement
                                    When the call is made
                                        Then the same WebElement is returned

                        * Given a page with multiple elements {
                            await setPageBody(`
                                <div id="one" class="big">foobar</div>
                                <a id="two" class="big">foobar</div>
                                <button id="three" class="big">foobar</div>
                            `);
                        }

                            * function $$() is called

                                * with a text EF

                                    * the EF has a counter {
                                        g('element passed in',
                                            `3 x .big`
                                        );
                                    }

                                    * the EF is missing a counter {
                                        g('element passed in',
                                            `.big`
                                        );
                                    }

                                * with an ElementFinder object

                                    * the EF has a counter {
                                        g('element passed in',
                                            new ElementFinder(`3 x .big`)
                                        );
                                    }

                                    * the EF is missing a counter {
                                        g('element passed in',
                                            new ElementFinder(`.big`)
                                        );
                                    }

                                * with a WebElement {
                                    g('element passed in',
                                        await browser.driver.findElement(By.id('two'))
                                    );
                                }

                                    * When the call is made {
                                        g('result elements',
                                            await $$(g('element passed in'))
                                        );
                                    }

                                        * Then the same WebElement is returned {
                                            expect(g('result elements')).to.have.lengthOf(1);
                                            expect(await g('result elements')[0].getAttribute('id')).to.equal('two');
                                        }

                                * When the call is made {
                                    g('result elements',
                                        await $$(g('element passed in'))
                                    );
                                }

                                    * Then all matching elements are returned {
                                        expect(g('result elements')).to.have.lengthOf(3);
                                        expect(await g('result elements')[0].getAttribute('id')).to.equal('one');
                                        expect(await g('result elements')[1].getAttribute('id')).to.equal('two');
                                        expect(await g('result elements')[2].getAttribute('id')).to.equal('three');
                                    }

                    - 'not$()' tests

                        Given a page with multiple elements {
                            await setPageBody(`
                                <div id="one" class="big">foobar</div>
                            `);
                        }

                            - and not$() is called

                                with a text EF that doesn't match anything {
                                    g('element', `.none`);
                                }
                                with an ElementFinder object that doesn't match anything {
                                    g('element', new ElementFinder(`.none`));
                                }

                                    no error is thrown {
                                        await not$(element, undefined, 1000);
                                    }

                                with an EF that continues to match after the timeout {
                                    g('element', `.big`);
                                }
                                with a valid WebElement that never disappears {
                                    g('element', await browser.driver.findElement(By.id('one')));
                                }

                                    an error is thrown {
                                        await expect(not$(element, undefined, 1000)).to.be.rejectedWith(`Element still found after timeout (1 s)`);
                                    }

                    - props() tests

                        - Setting one prop

                            - Given a prop is

                                - already defined

                                    define prop {
                                        props({
                                            fuzzy: `.original-fuzzy`
                                        });
                                    }

                                        - When that prop is set with props()

                                            - to an EF

                                                - with isAdd set to true

                                                    call {
                                                        props({
                                                            fuzzy: `.fuzzy`
                                                        }, true);
                                                    }

                                                        - Then the old definition gets added to

                                                            verify {
                                                                expect(browser.definedProps.fuzzy).to.have.lengthOf(2);
                                                                expect(browser.definedProps.fuzzy[0].props[0].input).to.equal('.original-fuzzy');
                                                                expect(browser.definedProps.fuzzy[1].props[0].input).to.equal('.fuzzy');
                                                            }

                                                - with isAdd set to false

                                                    call {
                                                        props({
                                                            fuzzy: `.fuzzy`
                                                        }, false);
                                                    }

                                                        - Then the old definition gets overridden

                                                            verify {
                                                                expect(browser.definedProps.fuzzy).to.have.lengthOf(1);
                                                                expect(browser.definedProps.fuzzy[0].props[0].input).to.equal('.fuzzy');
                                                            }

                                            - to a function

                                                - with isAdd set to true

                                                    call {
                                                        props({
                                                            fuzzy: (elems, input) => {
                                                                return elems.filter(elem => elem.classList.contains('fuzzy'))
                                                            }
                                                        }, true);
                                                    }

                                                        - Then the old definition gets added to

                                                            verify {
                                                                expect(browser.definedProps.fuzzy).to.have.lengthOf(2);
                                                                expect(browser.definedProps.fuzzy[0].props[0].input).to.equal('.original-fuzzy');
                                                                expect(typeof browser.definedProps.fuzzy[1]).to.equal('function');
                                                            }

                                                - with isAdd set to false

                                                    call {
                                                        props({
                                                            fuzzy: (elems, input) => {
                                                                return elems.filter(elem => elem.classList.contains('fuzzy'))
                                                            }
                                                        }, false);
                                                    }

                                                        - Then the old definition gets overridden

                                                            verify {
                                                                expect(browser.definedProps.fuzzy).to.have.lengthOf(1);
                                                                expect(typeof browser.definedProps.fuzzy[0]).to.equal('function');
                                                            }

                                - not yet defined

                                    - When that prop is set with props()

                                        *
                                            - with isAdd set to true

                                                call {
                                                    props({
                                                        fuzzy: `.fuzzy`
                                                    }, true);
                                                }

                                            - with isAdd set to false

                                                call {
                                                    props({
                                                        fuzzy: `.fuzzy`
                                                    }, false);
                                                }
                                        *

                                            - Then the definition gets set

                                                verify {
                                                    expect(browser.definedProps.fuzzy).to.have.lengthOf(1);
                                                    expect(browser.definedProps.fuzzy[0].props[0].input).to.equal('.fuzzy');
                                                }

                        - Setting multiple props

                            - When multiple props are set with props()
                                and some of those props have already been set {
                                    props({
                                        one: `.one`,
                                        two: `.two`,
                                        three: `.three`
                                    });
                                }

                                    - and isAdd is set to
                                        - true
                                            Then the existing definitions get added to {
                                                props({
                                                    one: `.first`,
                                                    three: (elems, input) => { return elems; }
                                                }, true);

                                                Comparer.expect(browser.definedProps).to.match({
                                                    one: [
                                                        { props: [ '$subset', {input: `.one`} ] },
                                                        { props: [ '$subset', {input: `.first`} ] }
                                                    ],
                                                    two: [
                                                        { props: [ '$subset', {input: `.two`} ] }
                                                    ],
                                                    three: [
                                                        { props: [ '$subset', {input: `.three`} ] },
                                                        { $typeof: 'function' }
                                                    ]
                                                });
                                            }

                                        - false
                                            Then the existing definitions get overriden {
                                                props({
                                                    one: `.first`,
                                                    three: (elems, input) => { return elems; }
                                                }, false);

                                                Comparer.expect(browser.definedProps).to.match({
                                                    one: [
                                                        { props: [ '$subset', {input: `.first`} ] }
                                                    ],
                                                    two: [
                                                        { props: [ '$subset', {input: `.two`} ] }
                                                    ],
                                                    three: [
                                                        { $typeof: 'function' }
                                                    ]
                                                });
                                            }

                    - propsAdd() tests
                        Setting a prop with an existing definition {
                            props({
                                fuzzy: `.original-fuzzy`
                            });

                            propsAdd({
                                fuzzy: `.fuzzy`
                            });
                        }
                            Verify that the old definition gets added to {
                                Comparer.expect(browser.definedProps).to.match({
                                    fuzzy: [
                                        { props: [ '$subset', {input: `.original-fuzzy`} ] },
                                        { props: [ '$subset', {input: `.fuzzy`} ] }
                                    ]
                                });
                            }

                    - propsClear() tests
                        Clears out multiple props {
                            props({
                                one: `.one`,
                                two: `.two`,
                                three: `.three`
                            });

                            propsClear(['one', 'two']);

                            Comparer.expect(browser.definedProps).to.match({
                                three: [
                                    { props: [ '$subset', {input: `.three`} ] }
                                ]
                            });
                        }
                        Silently handles props that don't exist {
                            props({
                                one: `.one`,
                                two: `.two`,
                                three: `.three`
                            });

                            propsClear(['one', 'two', 'foobar']);

                            Comparer.expect(browser.definedProps).to.match({
                                three: [
                                    { props: [ '$subset', {input: `.three`} ] }
                                ]
                            });
                        }

                    - str() tests
                        Escapes quotes in a string {
                            expect(`'${str(`"meow"`)}'`).to.equal(`'\\"meow\\"'`);
                        }

                - Mocks tests

                    - mockTime() tests

                        - When the mock date is set
                            - Then that change is visible from 'new Date()'

                    - mockHttp() tests

                        * Method is a
                            - GET
                            - POST
                        *
                            * Url is
                                - an absolute url

                                    - that's on browser's current domain
                                    - that's not on browser's current domain

                                - a relative url

                                - a regex
                            *
                                * Response is
                                    - a string

                                    - a js object

                                    - an array

                                        - Response body is
                                            - a string
                                            - an object

                                    - a function
                                *
                                    - When an http request is made from the browser
                                        - and that reponse is mocked
                                            - Then the mocked response comes back
                                        - and that response is not mocked
                                            - Then a 404 error comes back

                    - mockHttpConfigure() tests

                        - mockHttp() was
                            - already called
                                - Calling mockHttpConfigure()
                                    - Updates the config
                            - not called yet
                                - Calling mockHttpConfigure()
                                    - Does nothing

                    - mockTimeStop() tests
                        - mockTime() was
                            - already called
                                - Calling mockTimeStop()
                                    - Restores the current time
                            - not called yet
                                - Calling mockTimeStop()
                                    - Does nothing

                    - mockHttpStop() tests
                        - mockHttp() was
                            - already called
                                - Calling mockHttpStop()
                                    - and making an http request
                                        - Gets a response from the original non-mocked http server
                            - not called yet
                                - Calling mockHttpStop()
                                    - Does nothing

                    - mockStop() tests
                        - Calling mockStop() ..
                            - and using 'new Date()'
                                - Gets the current date
                            - and making an http request
                                - Gets a response from the original non-mocked http server

                    - injectSinon() tests

                        - Sinon already exists in browser
                        - Sinon does not already exist in browser

                            - Global sinon object is accessible within browser

                - Screenshots tests $s

                    make html page very long, with a button at the very bottom (below the fold) {
                        let body = '';
                        for(let i = 0; i < 500; i++) body += '<div>foobar</div>';
                        body += '<button>Click me</button>';
                        await setPageBody(body);
                    }
                        Click [button]
                            - Verify that the button is visible in the before screenshot, with crosshairs
